# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rspec-core` gem.
# Please instead update this file by running `bin/tapioca gem rspec-core`.

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings

  class << self
    def configuration; end
    def configure; end
    def const_missing(name); end
    def context(*args, &example_group_block); end
    def current_example; end
    def current_example=(example); end
    def describe(*args, &example_group_block); end
    def example_group(*args, &example_group_block); end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end
    def reset; end
    def shared_context(name, *args, &block); end
    def shared_examples(name, *args, &block); end
    def shared_examples_for(name, *args, &block); end
    def thread_local_metadata; end
    def world; end
    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
  end
end

module RSpec::Core
  class << self
    def path_to_executable; end
  end
end

class RSpec::Core::AnonymousExampleGroup < ::RSpec::Core::ExampleGroup
  class << self
    def metadata; end
  end
end

class RSpec::Core::BacktraceFormatter
  def initialize; end

  def backtrace_line(line); end
  def exclude?(line); end
  def exclusion_patterns; end
  def exclusion_patterns=(_arg0); end
  def filter_gem(gem_name); end
  def format_backtrace(backtrace, options = T.unsafe(nil)); end
  def full_backtrace=(_arg0); end
  def full_backtrace?; end
  def inclusion_patterns; end
  def inclusion_patterns=(_arg0); end

  private

  def matches?(patterns, line); end
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Hooks

  def initialize; end

  def add_formatter(formatter_to_use, *paths); end
  def add_setting(name, opts = T.unsafe(nil)); end
  def alias_example_group_to(new_name, *args); end
  def alias_example_to(name, *args); end
  def alias_it_behaves_like_to(new_name, report_label = T.unsafe(nil)); end
  def alias_it_should_behave_like_to(new_name, report_label = T.unsafe(nil)); end
  def apply_derived_metadata_to(metadata); end
  def backtrace_exclusion_patterns; end
  def backtrace_exclusion_patterns=(patterns); end
  def backtrace_formatter; end
  def backtrace_inclusion_patterns; end
  def backtrace_inclusion_patterns=(patterns); end
  def color; end
  def color=(true_or_false); end
  def color_enabled?(output = T.unsafe(nil)); end
  def configure_expectation_framework; end
  def configure_group(group); end
  def configure_mock_framework; end
  def default_color; end
  def default_color=(_arg0); end
  def default_color?; end
  def default_formatter; end
  def default_formatter=(value); end
  def default_path; end
  def default_path=(_arg0); end
  def default_path?; end
  def define_derived_metadata(*filters, &block); end
  def deprecation_stream; end
  def deprecation_stream=(value); end
  def detail_color; end
  def detail_color=(_arg0); end
  def detail_color?; end
  def disable_monkey_patching; end
  def disable_monkey_patching!; end
  def disable_monkey_patching=(_arg0); end
  def drb; end
  def drb=(_arg0); end
  def drb?; end
  def drb_port; end
  def drb_port=(_arg0); end
  def drb_port?; end
  def dry_run; end
  def dry_run=(_arg0); end
  def dry_run?; end
  def error_stream; end
  def error_stream=(_arg0); end
  def error_stream?; end
  def exclude_pattern; end
  def exclude_pattern=(value); end
  def exclusion_filter; end
  def exclusion_filter=(filter); end
  def expect_with(*frameworks); end
  def expectation_framework=(framework); end
  def expectation_frameworks; end
  def expecting_with_rspec; end
  def expecting_with_rspec=(_arg0); end
  def expecting_with_rspec?; end
  def expose_current_running_example_as(method_name); end
  def expose_dsl_globally=(value); end
  def expose_dsl_globally?; end
  def extend(mod, *filters); end
  def fail_fast; end
  def fail_fast=(_arg0); end
  def fail_fast?; end
  def failure_color; end
  def failure_color=(_arg0); end
  def failure_color?; end
  def failure_exit_code; end
  def failure_exit_code=(_arg0); end
  def failure_exit_code?; end
  def files_or_directories_to_run=(*files); end
  def files_to_run; end
  def files_to_run=(_arg0); end
  def filter; end
  def filter=(filter); end
  def filter_gems_from_backtrace(*gem_names); end
  def filter_manager; end
  def filter_manager=(_arg0); end
  def filter_run(*args); end
  def filter_run_excluding(*args); end
  def filter_run_including(*args); end
  def fixed_color; end
  def fixed_color=(_arg0); end
  def fixed_color?; end
  def force(hash); end
  def format_docstrings(&block); end
  def format_docstrings_block; end
  def formatter=(formatter_to_use, *paths); end
  def formatter_loader; end
  def formatters; end
  def full_backtrace=(true_or_false); end
  def full_backtrace?; end
  def full_description; end
  def full_description=(description); end
  def include(mod, *filters); end
  def include_or_extend_modules; end
  def include_or_extend_modules=(_arg0); end
  def include_or_extend_modules?; end
  def inclusion_filter; end
  def inclusion_filter=(filter); end
  def libs; end
  def libs=(libs); end
  def load_spec_files; end
  def mock_framework; end
  def mock_framework=(framework); end
  def mock_with(framework); end
  def order=(*args, &block); end
  def ordering_manager; end
  def ordering_registry(*args, &block); end
  def output_stream; end
  def output_stream=(value); end
  def pattern; end
  def pattern=(value); end
  def pending_color; end
  def pending_color=(_arg0); end
  def pending_color?; end
  def profile_examples; end
  def profile_examples=(_arg0); end
  def profile_examples?; end
  def raise_errors_for_deprecations!; end
  def register_ordering(*args, &block); end
  def reporter; end
  def requires; end
  def requires=(paths); end
  def reset; end
  def run_all_when_everything_filtered; end
  def run_all_when_everything_filtered=(_arg0); end
  def run_all_when_everything_filtered?; end
  def safe_extend(mod, host); end
  def safe_include(mod, host); end
  def seed(*args, &block); end
  def seed=(*args, &block); end
  def seed_used?(*args, &block); end
  def start_time; end
  def start_time=(_arg0); end
  def start_time?; end
  def success_color; end
  def success_color=(_arg0); end
  def success_color?; end
  def treat_symbols_as_metadata_keys_with_true_values=(_value); end
  def tty; end
  def tty=(_arg0); end
  def tty?; end
  def warnings=(value); end
  def warnings?; end

  private

  def absolute_pattern?(pattern); end
  def assert_no_example_groups_defined(config_option); end
  def command; end
  def conditionally_disable_expectations_monkey_patching; end
  def conditionally_disable_mocks_monkey_patching; end
  def extract_location(path); end
  def file_glob_from(path, pattern); end
  def gather_directories(path); end
  def get_files_to_run(paths); end
  def get_matching_files(path, pattern); end
  def output_to_tty?(output = T.unsafe(nil)); end
  def paths_to_check(paths); end
  def pattern_might_load_specs_from_vendored_dirs?; end
  def rspec_expectations_loaded?; end
  def rspec_mocks_loaded?; end
  def update_pattern_attr(name, value); end
  def value_for(key, default = T.unsafe(nil)); end

  class << self
    def add_read_only_setting(name, opts = T.unsafe(nil)); end
    def add_setting(name, opts = T.unsafe(nil)); end
    def define_aliases(name, alias_name); end
    def define_predicate_for(*names); end
    def define_reader(name); end
    def delegate_to_ordering_manager(*methods); end
  end
end

RSpec::Core::Configuration::DEFAULT_FORMATTER = T.let(T.unsafe(nil), Proc)

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def initialize; end

  def deprecation(*args); end
  def play_onto(reporter); end
end

module RSpec::Core::Configuration::ExposeCurrentExample; end
RSpec::Core::Configuration::MOCKING_ADAPTERS = T.let(T.unsafe(nil), Hash)
class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError < ::StandardError; end

class RSpec::Core::ConfigurationOptions
  def initialize(args); end

  def configure(config); end
  def configure_filter_manager(filter_manager); end
  def options; end

  private

  def args_from_options_file(path); end
  def command_line_options; end
  def custom_options; end
  def custom_options_file; end
  def env_options; end
  def file_options; end
  def force?(key); end
  def global_options; end
  def global_options_file; end
  def load_formatters_into(config); end
  def local_options; end
  def local_options_file; end
  def options_file_as_erb_string(path); end
  def options_from(path); end
  def order(keys); end
  def organize_options; end
  def process_options_into(config); end
  def project_options; end
  def project_options_file; end
end

RSpec::Core::ConfigurationOptions::OPTIONS_ORDER = T.let(T.unsafe(nil), Array)
RSpec::Core::ConfigurationOptions::UNFORCED_OPTIONS = T.let(T.unsafe(nil), Set)
RSpec::Core::ConfigurationOptions::UNPROCESSABLE_OPTIONS = T.let(T.unsafe(nil), Set)

module RSpec::Core::DSL
  class << self
    def change_global_dsl(&changes); end
    def example_group_aliases; end
    def expose_example_group_alias(name); end
    def expose_example_group_alias_globally(method_name); end
    def expose_globally!; end
    def exposed_globally?; end
    def remove_globally!; end
    def top_level; end
    def top_level=(_arg0); end
  end
end

class RSpec::Core::DeprecationError < ::StandardError; end

class RSpec::Core::Example
  def initialize(example_group_class, description, user_metadata, example_block = T.unsafe(nil)); end

  def all_apply?(filters); end
  def any_apply?(filters); end
  def around_example_hooks; end
  def clock; end
  def clock=(_arg0); end
  def description; end
  def example_group; end
  def example_group_instance; end
  def exception; end
  def execution_result; end
  def fail_with_exception(reporter, exception); end
  def file_path; end
  def full_description; end
  def instance_exec(*args, &block); end
  def instance_exec_with_rescue(context, &block); end
  def location; end
  def metadata; end
  def pending; end
  def pending?; end
  def run(example_group_instance, reporter); end
  def set_exception(exception, context = T.unsafe(nil)); end
  def skip; end
  def skip_with_exception(reporter, exception); end
  def skipped?; end

  private

  def assign_generated_description; end
  def finish(reporter); end
  def mocks_need_verification?; end
  def record_finished(status); end
  def run_after_example; end
  def run_before_example; end
  def skip_message; end
  def start(reporter); end
  def verify_mocks; end
  def with_around_example_hooks(&block); end

  class << self
    def delegate_to_metadata(key); end
  end
end

class RSpec::Core::Example::ExecutionResult
  include ::RSpec::Core::HashImitatable
  extend ::RSpec::Core::HashImitatable::ClassMethods

  def exception; end
  def exception=(_arg0); end
  def finished_at; end
  def finished_at=(_arg0); end
  def pending_exception; end
  def pending_exception=(_arg0); end
  def pending_fixed; end
  def pending_fixed=(_arg0); end
  def pending_fixed?; end
  def pending_message; end
  def pending_message=(_arg0); end
  def record_finished(status, finished_at); end
  def run_time; end
  def run_time=(_arg0); end
  def started_at; end
  def started_at=(_arg0); end
  def status; end
  def status=(_arg0); end

  private

  def get_value(name); end
  def hash_for_delegation; end
  def issue_deprecation(_method_name, *_args); end
  def set_value(name, value); end
end

class RSpec::Core::Example::Procsy
  def initialize(example, &block); end

  def <<(*a, &b); end
  def ==(*a, &b); end
  def ===(*a, &b); end
  def >>(*a, &b); end
  def [](*a, &b); end
  def arity(*a, &b); end
  def binding(*a, &b); end
  def call(*args, &block); end
  def clock(*a, &b); end
  def clock=(*a, &b); end
  def clone(*a, &b); end
  def curry(*a, &b); end
  def description(*a, &b); end
  def dup(*a, &b); end
  def eql?(*a, &b); end
  def example; end
  def example_group(*a, &b); end
  def example_group_instance(*a, &b); end
  def exception(*a, &b); end
  def executed?; end
  def execution_result(*a, &b); end
  def file_path(*a, &b); end
  def full_description(*a, &b); end
  def hash(*a, &b); end
  def inspect; end
  def lambda?(*a, &b); end
  def location(*a, &b); end
  def metadata(*a, &b); end
  def parameters(*a, &b); end
  def pending(*a, &b); end
  def pending?(*a, &b); end
  def ruby2_keywords(*a, &b); end
  def run(*args, &block); end
  def skip(*a, &b); end
  def skipped?(*a, &b); end
  def source_location(*a, &b); end
  def to_proc; end
  def to_s(*a, &b); end
  def wrap(&block); end
  def yield(*a, &b); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MemoizedHelpers
  include ::RSpec::Core::Pending
  extend ::RSpec::Core::Hooks
  extend ::RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::RSpec::Core::SharedExampleGroup

  def described_class; end

  class << self
    def all_apply?(filters); end
    def any_apply?(filters); end
    def before_context_ivars; end
    def children; end
    def context(*args, &example_group_block); end
    def declaration_line_numbers; end
    def define_example_group_method(name, metadata = T.unsafe(nil)); end
    def define_example_method(name, extra_options = T.unsafe(nil)); end
    def define_nested_shared_group_method(new_name, report_label = T.unsafe(nil)); end
    def delegate_to_metadata(*names); end
    def descendant_filtered_examples; end
    def descendants; end
    def describe(*args, &example_group_block); end
    def described_class; end
    def description; end
    def ensure_example_groups_are_configured; end
    def example(*all_args, &block); end
    def example_group(*args, &example_group_block); end
    def examples; end
    def fail_fast?; end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end
    def fexample(*all_args, &block); end
    def file_path; end
    def filtered_examples; end
    def find_and_eval_shared(label, name, *args, &customization_block); end
    def fit(*all_args, &block); end
    def focus(*all_args, &block); end
    def for_filtered_examples(reporter, &block); end
    def fspecify(*all_args, &block); end
    def include_context(name, *args, &block); end
    def include_examples(name, *args, &block); end
    def it(*all_args, &block); end
    def it_behaves_like(name, *args, &customization_block); end
    def it_should_behave_like(name, *args, &customization_block); end
    def location; end
    def metadata; end
    def ordering_strategy; end
    def parent_groups; end
    def pending(*all_args, &block); end
    def run(reporter); end
    def run_after_context_hooks(example_group_instance); end
    def run_before_context_hooks(example_group_instance); end
    def run_examples(reporter); end
    def set_it_up(*args, &example_group_block); end
    def set_ivars(instance, ivars); end
    def skip(*all_args, &block); end
    def specify(*all_args, &block); end
    def store_before_context_ivars(example_group_instance); end
    def subclass(parent, description, args, &example_group_block); end
    def superclass_metadata; end
    def top_level?; end
    def top_level_description; end
    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
    def xexample(*all_args, &block); end
    def xit(*all_args, &block); end
    def xspecify(*all_args, &block); end
  end
end

class RSpec::Core::ExclusionRules < ::RSpec::Core::FilterRules
  def include_example?(example); end
end

RSpec::Core::ExclusionRules::CONDITIONAL_FILTERS = T.let(T.unsafe(nil), Hash)

class RSpec::Core::FilterManager
  def initialize; end

  def add_location(file_path, line_numbers); end
  def empty?; end
  def exclude(*args); end
  def exclude?(example); end
  def exclude_only(*args); end
  def exclude_with_low_priority(*args); end
  def exclusions; end
  def include(*args); end
  def include?(example); end
  def include_only(*args); end
  def include_with_low_priority(*args); end
  def inclusions; end
  def prune(examples); end
end

class RSpec::Core::FilterRules
  def initialize(*args, &block); end

  def [](key); end
  def add(updated); end
  def add_with_low_priority(updated); end
  def clear; end
  def delete(key); end
  def description; end
  def each_pair(&block); end
  def empty?; end
  def fetch(*args, &block); end
  def opposite; end
  def opposite=(_arg0); end
  def rules; end
  def use_only(updated); end

  class << self
    def build; end
  end
end

RSpec::Core::FilterRules::PROC_HEX_NUMBER = T.let(T.unsafe(nil), Regexp)
RSpec::Core::FilterRules::PROJECT_DIR = T.let(T.unsafe(nil), String)

module RSpec::Core::FlatMap
  private

  def flat_map(array); end

  class << self
    def flat_map(array); end
  end
end

module RSpec::Core::Formatters
  class << self
    def register(formatter_class, *notifications); end
  end
end

class RSpec::Core::Formatters::BaseFormatter
  def initialize(output); end

  def close(_notification); end
  def example_group; end
  def example_group=(_arg0); end
  def example_group_started(notification); end
  def output; end
  def start(notification); end

  private

  def output_supports_sync; end
  def restore_sync_output; end
  def start_sync_output; end
end

class RSpec::Core::Formatters::BaseTextFormatter < ::RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end
  def dump_failures(notification); end
  def dump_pending(notification); end
  def dump_summary(summary); end
  def message(notification); end
  def seed(notification); end
end

module RSpec::Core::Formatters::ConsoleCodes
  private

  def configuration_color(code); end
  def console_code_for(code_or_symbol); end
  def wrap(text, code_or_symbol); end

  class << self
    def configuration_color(code); end
    def console_code_for(code_or_symbol); end
    def wrap(text, code_or_symbol); end
  end
end

RSpec::Core::Formatters::ConsoleCodes::VT100_CODES = T.let(T.unsafe(nil), Hash)
RSpec::Core::Formatters::ConsoleCodes::VT100_CODE_VALUES = T.let(T.unsafe(nil), Hash)

class RSpec::Core::Formatters::DeprecationFormatter
  def initialize(deprecation_stream, summary_stream); end

  def count; end
  def deprecation(notification); end
  def deprecation_message_for(data); end
  def deprecation_stream; end
  def deprecation_summary(_notification); end
  def output; end
  def printer; end
  def summary_stream; end
end

RSpec::Core::Formatters::DeprecationFormatter::DEPRECATION_STREAM_NOTICE = T.let(T.unsafe(nil), String)

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def deprecation_formatter; end
  def deprecation_stream; end
  def deprecation_summary; end
  def print_deferred_deprecation_warnings; end
  def print_deprecation_message(data); end
  def stash_deprecation_message(deprecation_message); end
  def summary_stream; end
end

RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter::TOO_MANY_USES_LIMIT = T.let(T.unsafe(nil), Integer)

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end
  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage < ::Struct
  def initialize(data); end

  def to_s; end
  def too_many_warnings_message; end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def deprecation_formatter; end
  def deprecation_stream; end
  def deprecation_summary; end
  def print_deprecation_message(data); end
  def summary_stream; end
end

RSpec::Core::Formatters::DeprecationFormatter::RAISE_ERROR_CONFIG_NOTICE = T.let(T.unsafe(nil), String)

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end
  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage < ::Struct
  def initialize(data); end

  def to_s; end
  def too_many_warnings_message; end
  def type; end
  def type=(_); end

  private

  def deprecation_type_for(data); end
  def output_formatted(str); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RSpec::Core::Formatters::DocumentationFormatter < ::RSpec::Core::Formatters::BaseTextFormatter
  def initialize(output); end

  def example_failed(failure); end
  def example_group_finished(_notification); end
  def example_group_started(notification); end
  def example_passed(passed); end
  def example_pending(pending); end

  private

  def current_indentation; end
  def example_group_chain; end
  def failure_output(example, _exception); end
  def next_failure_index; end
  def passed_output(example); end
  def pending_output(example, message); end
end

module RSpec::Core::Formatters::Helpers
  class << self
    def format_duration(duration); end
    def format_seconds(float, precision = T.unsafe(nil)); end
    def pluralize(count, string); end

    private

    def strip_trailing_zeroes(string); end
  end
end

RSpec::Core::Formatters::Helpers::DEFAULT_PRECISION = T.let(T.unsafe(nil), Integer)
RSpec::Core::Formatters::Helpers::SUB_SECOND_PRECISION = T.let(T.unsafe(nil), Integer)

class RSpec::Core::Formatters::HtmlFormatter < ::RSpec::Core::Formatters::BaseFormatter
  def initialize(output); end

  def dump_summary(summary); end
  def example_failed(failure); end
  def example_group_started(notification); end
  def example_passed(passed); end
  def example_pending(pending); end
  def example_started(_notification); end
  def start(notification); end
  def start_dump(_notification); end

  private

  def example_group_number; end
  def example_number; end
  def extra_failure_content(failure); end
  def percent_done; end
end

class RSpec::Core::Formatters::HtmlPrinter
  include ::ERB::Util

  def initialize(output); end

  def flush; end
  def make_example_group_header_red(group_id); end
  def make_example_group_header_yellow(group_id); end
  def make_header_red; end
  def make_header_yellow; end
  def move_progress(percent_done); end
  def print_example_failed(pending_fixed, description, run_time, failure_id, exception, extra_content, escape_backtrace = T.unsafe(nil)); end
  def print_example_group_end; end
  def print_example_group_start(group_id, description, number_of_parents); end
  def print_example_passed(description, run_time); end
  def print_example_pending(description, pending_message); end
  def print_html_start; end
  def print_summary(duration, example_count, failure_count, pending_count); end

  private

  def indentation_style(number_of_parents); end
end

RSpec::Core::Formatters::HtmlPrinter::GLOBAL_SCRIPTS = T.let(T.unsafe(nil), String)
RSpec::Core::Formatters::HtmlPrinter::GLOBAL_STYLES = T.let(T.unsafe(nil), String)
RSpec::Core::Formatters::HtmlPrinter::HTML_HEADER = T.let(T.unsafe(nil), String)
RSpec::Core::Formatters::HtmlPrinter::REPORT_HEADER = T.let(T.unsafe(nil), String)

class RSpec::Core::Formatters::JsonFormatter < ::RSpec::Core::Formatters::BaseFormatter
  def initialize(output); end

  def close(_notification); end
  def dump_profile(profile); end
  def dump_profile_slowest_example_groups(profile); end
  def dump_profile_slowest_examples(profile); end
  def dump_summary(summary); end
  def message(notification); end
  def output_hash; end
  def stop(notification); end

  private

  def format_example(example); end
end

class RSpec::Core::Formatters::Loader
  def initialize(reporter); end

  def add(formatter_to_use, *paths); end
  def default_formatter; end
  def default_formatter=(_arg0); end
  def formatters; end
  def reporter; end
  def setup_default(output_stream, deprecation_stream); end

  private

  def built_in_formatter(key); end
  def custom_formatter(formatter_ref); end
  def duplicate_formatter_exists?(new_formatter); end
  def existing_formatter_implements?(notification); end
  def file_at(path); end
  def find_formatter(formatter_to_use); end
  def notifications_for(formatter_class); end
  def path_for(const_ref); end
  def string_const?(str); end
  def underscore(camel_cased_word); end
  def underscore_with_fix_for_non_standard_rspec_naming(string); end

  class << self
    def formatters; end
  end
end

class RSpec::Core::Formatters::ProfileFormatter
  def initialize(output); end

  def dump_profile(profile); end
  def output; end

  private

  def bold(text); end
  def dump_profile_slowest_example_groups(profile); end
  def dump_profile_slowest_examples(profile); end
  def format_caller(caller_info); end
end

class RSpec::Core::Formatters::ProgressFormatter < ::RSpec::Core::Formatters::BaseTextFormatter
  def example_failed(_notification); end
  def example_passed(_notification); end
  def example_pending(_notification); end
  def start_dump(_notification); end
end

module RSpec::Core::HashImitatable
  mixes_in_class_methods ::RSpec::Core::HashImitatable::ClassMethods

  def <(*args, &block); end
  def <=(*args, &block); end
  def >(*args, &block); end
  def >=(*args, &block); end
  def [](key); end
  def []=(key, value); end
  def all?(*args, &block); end
  def any?(*args, &block); end
  def assoc(*args, &block); end
  def chain(*args, &block); end
  def chunk(*args, &block); end
  def chunk_while(*args, &block); end
  def clear(*args, &block); end
  def collect(*args, &block); end
  def collect_concat(*args, &block); end
  def compact(*args, &block); end
  def compact!(*args, &block); end
  def compare_by_identity(*args, &block); end
  def compare_by_identity?(*args, &block); end
  def count(*args, &block); end
  def cycle(*args, &block); end
  def deconstruct_keys(*args, &block); end
  def default(*args, &block); end
  def default=(*args, &block); end
  def default_proc(*args, &block); end
  def default_proc=(*args, &block); end
  def delete(*args, &block); end
  def delete_if(*args, &block); end
  def detect(*args, &block); end
  def dig(*args, &block); end
  def drop(*args, &block); end
  def drop_while(*args, &block); end
  def each(*args, &block); end
  def each_cons(*args, &block); end
  def each_entry(*args, &block); end
  def each_key(*args, &block); end
  def each_pair(*args, &block); end
  def each_slice(*args, &block); end
  def each_value(*args, &block); end
  def each_with_index(*args, &block); end
  def each_with_object(*args, &block); end
  def empty?(*args, &block); end
  def entries(*args, &block); end
  def except(*args, &block); end
  def fetch(*args, &block); end
  def fetch_values(*args, &block); end
  def filter(*args, &block); end
  def filter!(*args, &block); end
  def filter_map(*args, &block); end
  def find(*args, &block); end
  def find_all(*args, &block); end
  def find_index(*args, &block); end
  def first(*args, &block); end
  def flat_map(*args, &block); end
  def flatten(*args, &block); end
  def grep(*args, &block); end
  def grep_v(*args, &block); end
  def group_by(*args, &block); end
  def has_key?(*args, &block); end
  def has_value?(*args, &block); end
  def include?(*args, &block); end
  def inject(*args, &block); end
  def invert(*args, &block); end
  def keep_if(*args, &block); end
  def key(*args, &block); end
  def key?(*args, &block); end
  def keys(*args, &block); end
  def lazy(*args, &block); end
  def length(*args, &block); end
  def map(*args, &block); end
  def max(*args, &block); end
  def max_by(*args, &block); end
  def member?(*args, &block); end
  def merge(*args, &block); end
  def merge!(*args, &block); end
  def min(*args, &block); end
  def min_by(*args, &block); end
  def minmax(*args, &block); end
  def minmax_by(*args, &block); end
  def none?(*args, &block); end
  def one?(*args, &block); end
  def partition(*args, &block); end
  def rassoc(*args, &block); end
  def reduce(*args, &block); end
  def rehash(*args, &block); end
  def reject(*args, &block); end
  def reject!(*args, &block); end
  def replace(*args, &block); end
  def reverse_each(*args, &block); end
  def select(*args, &block); end
  def select!(*args, &block); end
  def shift(*args, &block); end
  def size(*args, &block); end
  def slice(*args, &block); end
  def slice_after(*args, &block); end
  def slice_before(*args, &block); end
  def slice_when(*args, &block); end
  def sort(*args, &block); end
  def sort_by(*args, &block); end
  def store(*args, &block); end
  def sum(*args, &block); end
  def take(*args, &block); end
  def take_while(*args, &block); end
  def tally(*args, &block); end
  def to_a(*args, &block); end
  def to_h; end
  def to_hash(*args, &block); end
  def to_proc(*args, &block); end
  def to_set(*args, &block); end
  def transform_keys(*args, &block); end
  def transform_keys!(*args, &block); end
  def transform_values(*args, &block); end
  def transform_values!(*args, &block); end
  def uniq(*args, &block); end
  def update(*args, &block); end
  def value?(*args, &block); end
  def values(*args, &block); end
  def values_at(*args, &block); end
  def zip(*args, &block); end

  private

  def directly_supports_attribute?(name); end
  def extra_hash_attributes; end
  def get_value(name); end
  def hash_for_delegation; end
  def issue_deprecation(_method_name, *_args); end
  def set_value(name, value); end

  class << self
    def included(klass); end
  end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end
  def hash_attribute_names; end
end

module RSpec::Core::Hooks
  def after(*args, &block); end
  def append_after(*args, &block); end
  def append_before(*args, &block); end
  def around(*args, &block); end
  def before(*args, &block); end
  def hooks; end
  def prepend_after(*args, &block); end
  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook < ::RSpec::Core::Hooks::Hook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook < ::RSpec::Core::Hooks::Hook
  def run(example); end
end

class RSpec::Core::Hooks::AroundHook < ::RSpec::Core::Hooks::Hook
  def execute_with(example, procsy); end
  def hook_description; end
end

class RSpec::Core::Hooks::AroundHookCollection < ::RSpec::Core::Hooks::BaseHookCollection
  def for(example, initial_procsy = T.unsafe(nil)); end
  def run; end
  def with(example, initial_procsy); end
end

class RSpec::Core::Hooks::BaseHookCollection
  def initialize(hooks = T.unsafe(nil)); end

  def &(*a, &b); end
  def *(*a, &b); end
  def +(*a, &b); end
  def -(*a, &b); end
  def <<(*a, &b); end
  def <=>(*a, &b); end
  def ==(*a, &b); end
  def [](*a, &b); end
  def []=(*a, &b); end
  def all?(*a, &b); end
  def any?(*a, &b); end
  def append(*a, &b); end
  def assoc(*a, &b); end
  def at(*a, &b); end
  def bsearch(*a, &b); end
  def bsearch_index(*a, &b); end
  def clear(*a, &b); end
  def collect(*a, &b); end
  def collect!(*a, &b); end
  def combination(*a, &b); end
  def compact(*a, &b); end
  def compact!(*a, &b); end
  def concat(*a, &b); end
  def count(*a, &b); end
  def cycle(*a, &b); end
  def deconstruct(*a, &b); end
  def delete(*a, &b); end
  def delete_at(*a, &b); end
  def delete_if(*a, &b); end
  def difference(*a, &b); end
  def dig(*a, &b); end
  def drop(*a, &b); end
  def drop_while(*a, &b); end
  def each(*a, &b); end
  def each_index(*a, &b); end
  def empty?(*a, &b); end
  def eql?(*a, &b); end
  def fetch(*a, &b); end
  def fill(*a, &b); end
  def filter(*a, &b); end
  def filter!(*a, &b); end
  def find_index(*a, &b); end
  def first(*a, &b); end
  def flatten(*a, &b); end
  def flatten!(*a, &b); end
  def hash(*a, &b); end
  def include?(*a, &b); end
  def index(*a, &b); end
  def insert(*a, &b); end
  def inspect(*a, &b); end
  def intersect?(*a, &b); end
  def intersection(*a, &b); end
  def join(*a, &b); end
  def keep_if(*a, &b); end
  def last(*a, &b); end
  def length(*a, &b); end
  def map(*a, &b); end
  def map!(*a, &b); end
  def max(*a, &b); end
  def min(*a, &b); end
  def minmax(*a, &b); end
  def none?(*a, &b); end
  def one?(*a, &b); end
  def pack(*a, &b); end
  def permutation(*a, &b); end
  def place(*a, &b); end
  def pop(*a, &b); end
  def prepend(*a, &b); end
  def product(*a, &b); end
  def push(*a, &b); end
  def rassoc(*a, &b); end
  def reject(*a, &b); end
  def reject!(*a, &b); end
  def repeated_combination(*a, &b); end
  def repeated_permutation(*a, &b); end
  def replace(*a, &b); end
  def reverse(*a, &b); end
  def reverse!(*a, &b); end
  def reverse_each(*a, &b); end
  def rindex(*a, &b); end
  def rotate(*a, &b); end
  def rotate!(*a, &b); end
  def sample(*a, &b); end
  def select(*a, &b); end
  def select!(*a, &b); end
  def shelljoin(*a, &b); end
  def shift(*a, &b); end
  def shuffle(*a, &b); end
  def shuffle!(*a, &b); end
  def size(*a, &b); end
  def slice(*a, &b); end
  def slice!(*a, &b); end
  def sort(*a, &b); end
  def sort!(*a, &b); end
  def sort_by!(*a, &b); end
  def sum(*a, &b); end
  def take(*a, &b); end
  def take_while(*a, &b); end
  def to_a(*a, &b); end
  def to_ary(*a, &b); end
  def to_h(*a, &b); end
  def to_s(*a, &b); end
  def transpose(*a, &b); end
  def union(*a, &b); end
  def uniq(*a, &b); end
  def uniq!(*a, &b); end
  def unshift(*a, &b); end
  def values_at(*a, &b); end
  def zip(*a, &b); end
  def |(*a, &b); end

  protected

  def hooks; end
end

class RSpec::Core::Hooks::BeforeHook < ::RSpec::Core::Hooks::Hook
  def run(example); end
end

class RSpec::Core::Hooks::GroupHookCollection < ::RSpec::Core::Hooks::BaseHookCollection
  def for(group); end
  def run; end
end

class RSpec::Core::Hooks::Hook
  def initialize(block, options); end

  def block; end
  def options; end
  def options_apply?(example_or_group); end
end

class RSpec::Core::Hooks::HookCollection < ::RSpec::Core::Hooks::BaseHookCollection
  def for(example_or_group); end
  def run; end
  def with(example); end
end

class RSpec::Core::Hooks::HookCollections
  def initialize(owner, data); end

  def [](key); end
  def around_example_hooks_for(example, initial_procsy = T.unsafe(nil)); end
  def register(prepend_or_append, hook, *args, &block); end
  def register_globals(host, globals); end
  def run(hook, scope, example_or_group, initial_procsy = T.unsafe(nil)); end

  private

  def after_context_hooks_for(group); end
  def after_example_hooks_for(example); end
  def before_context_hooks_for(group); end
  def before_example_hooks_for(example); end
  def extract_scope_from(args); end
  def find_hook(hook, scope, example_or_group, initial_procsy); end
  def known_scope?(scope); end
  def normalized_scope_for(scope); end
  def process(host, globals, position, scope); end
  def scope_and_options_from(*args); end
end

RSpec::Core::Hooks::HookCollections::HOOK_TYPES = T.let(T.unsafe(nil), Hash)
RSpec::Core::Hooks::HookCollections::SCOPES = T.let(T.unsafe(nil), Array)
RSpec::Core::Hooks::HookCollections::SCOPE_ALIASES = T.let(T.unsafe(nil), Hash)

class RSpec::Core::InclusionRules < ::RSpec::Core::FilterRules
  def add(*args); end
  def add_location(locations); end
  def add_with_low_priority(*args); end
  def include_example?(example); end
  def standalone?; end
  def use(*args); end

  private

  def apply_standalone_filter(updated); end
  def is_standalone_filter?(rules); end
  def replace_filters(new_rules); end
end

RSpec::Core::InclusionRules::STANDALONE_FILTERS = T.let(T.unsafe(nil), Array)

class RSpec::Core::LegacyExampleGroupHash
  include ::RSpec::Core::HashImitatable
  extend ::RSpec::Core::HashImitatable::ClassMethods

  def initialize(metadata); end

  def to_h; end

  private

  def directly_supports_attribute?(name); end
  def get_value(name); end
  def set_value(name, value); end
end

module RSpec::Core::MemoizedHelpers
  def is_expected; end
  def should(matcher = T.unsafe(nil), message = T.unsafe(nil)); end
  def should_not(matcher = T.unsafe(nil), message = T.unsafe(nil)); end
  def subject; end

  private

  def __memoized; end

  class << self
    def define_helpers_on(example_group); end
    def get_constant_or_yield(example_group, name); end
    def module_for(example_group); end
  end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end
  def let!(name, &block); end
  def subject(name = T.unsafe(nil), &block); end
  def subject!(name = T.unsafe(nil), &block); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoizedHash
  class << self
    def fetch(key, &_block); end
    def isolate_for_context_hook(example_group_instance); end
  end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoizedHash::After < ::RSpec::Core::MemoizedHelpers::ContextHookMemoizedHash
  class << self
    def article; end
    def hook_expression; end
    def hook_intention; end
  end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoizedHash::Before < ::RSpec::Core::MemoizedHelpers::ContextHookMemoizedHash
  class << self
    def article; end
    def hook_expression; end
    def hook_intention; end
  end
end

module RSpec::Core::Metadata
  class << self
    def backtrace_from(block); end
    def build_hash_from(args, warn_about_example_group_filtering = T.unsafe(nil)); end
    def relative_path(line); end
  end
end

class RSpec::Core::Metadata::ExampleGroupHash < ::RSpec::Core::Metadata::HashPopulator
  private

  def described_class; end
  def full_description; end

  class << self
    def backwards_compatibility_default_proc(&example_group_selector); end
    def create(parent_group_metadata, user_metadata, *args, &block); end
    def hash_with_backwards_compatibility_default_proc; end
  end
end

class RSpec::Core::Metadata::ExampleHash < ::RSpec::Core::Metadata::HashPopulator
  private

  def described_class; end
  def full_description; end

  class << self
    def create(group_metadata, user_metadata, description, block); end
  end
end

class RSpec::Core::Metadata::HashPopulator
  def initialize(metadata, user_metadata, description_args, block); end

  def block; end
  def description_args; end
  def metadata; end
  def populate; end
  def user_metadata; end

  private

  def build_description_from(parent_description = T.unsafe(nil), my_description = T.unsafe(nil)); end
  def description_separator(parent_part, child_part); end
  def ensure_valid_user_keys; end
  def file_path_and_line_number_from(backtrace); end
  def populate_location_attributes; end
end

RSpec::Core::Metadata::RESERVED_KEYS = T.let(T.unsafe(nil), Array)

module RSpec::Core::MetadataFilter
  class << self
    def all_apply?(filters, metadata); end
    def any_apply?(filters, metadata); end
    def filter_applies?(key, value, metadata); end

    private

    def example_group_declaration_line(locations, metadata); end
    def filter_applies_to_any_value?(key, value, metadata); end
    def filters_apply?(key, value, metadata); end
    def line_number_filter_applies?(line_numbers, metadata); end
    def location_filter_applies?(locations, metadata); end
    def parent_of(metadata); end
    def relevant_line_numbers(metadata); end
    def silence_metadata_example_group_deprecations; end
  end
end

module RSpec::Core::Notifications; end

class RSpec::Core::Notifications::DeprecationNotification < ::Struct
  def call_site; end
  def call_site=(_); end
  def deprecated; end
  def deprecated=(_); end
  def message; end
  def message=(_); end
  def replacement; end
  def replacement=(_); end

  class << self
    def [](*_arg0); end
    def from_hash(data); end
    def inspect; end
    def keyword_init?; end
    def members; end

    private

    def new(*_arg0); end
  end
end

class RSpec::Core::Notifications::ExampleNotification < ::Struct
  def example; end
  def example=(_); end

  class << self
    def [](*_arg0); end
    def for(example); end
    def inspect; end
    def keyword_init?; end
    def members; end

    private

    def new(*_arg0); end
  end
end

class RSpec::Core::Notifications::ExamplesNotification
  def initialize(reporter); end

  def examples; end
  def failed_examples; end
  def failure_notifications; end
  def fully_formatted_failed_examples(colorizer = T.unsafe(nil)); end
  def fully_formatted_pending_examples(colorizer = T.unsafe(nil)); end
  def notifications; end
  def pending_examples; end

  private

  def format_examples(examples); end
end

class RSpec::Core::Notifications::FailedExampleNotification < ::RSpec::Core::Notifications::ExampleNotification
  def colorized_formatted_backtrace(colorizer = T.unsafe(nil)); end
  def colorized_message_lines(colorizer = T.unsafe(nil)); end
  def description; end
  def exception; end
  def formatted_backtrace; end
  def fully_formatted(failure_number, colorizer = T.unsafe(nil)); end
  def message_lines; end

  private

  def add_shared_group_line(lines, colorizer); end
  def backtrace_formatter; end
  def encoding_of(string); end
  def exception_class_name; end
  def failure_lines; end
  def find_failed_line; end
  def group_and_parent_groups; end
  def read_failed_line; end
  def shared_group; end
  def shared_group_line; end
end

class RSpec::Core::Notifications::GroupNotification < ::Struct
  def group; end
  def group=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RSpec::Core::Notifications::MessageNotification < ::Struct
  def message; end
  def message=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module RSpec::Core::Notifications::NullColorizer
  private

  def wrap(line, _code_or_symbol); end

  class << self
    def wrap(line, _code_or_symbol); end
  end
end

class RSpec::Core::Notifications::NullNotification; end

class RSpec::Core::Notifications::PendingExampleFixedNotification < ::RSpec::Core::Notifications::FailedExampleNotification
  def colorized_message_lines(colorizer = T.unsafe(nil)); end
  def description; end
  def message_lines; end
end

class RSpec::Core::Notifications::ProfileNotification < ::Struct
  def duration; end
  def duration=(_); end
  def examples; end
  def examples=(_); end
  def number_of_examples; end
  def number_of_examples=(_); end
  def percentage; end
  def slow_duration; end
  def slowest_examples; end
  def slowest_groups; end

  private

  def calculate_slowest_groups; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RSpec::Core::Notifications::SeedNotification < ::Struct
  def fully_formatted; end
  def seed; end
  def seed=(_); end
  def seed_used?; end
  def used=(_); end

  private

  def used; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RSpec::Core::Notifications::StartNotification < ::Struct
  def count; end
  def count=(_); end
  def load_time; end
  def load_time=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RSpec::Core::Notifications::SummaryNotification < ::Struct
  def colorized_rerun_commands(colorizer = T.unsafe(nil)); end
  def colorized_totals_line(colorizer = T.unsafe(nil)); end
  def duration; end
  def duration=(_); end
  def example_count; end
  def examples; end
  def examples=(_); end
  def failed_examples; end
  def failed_examples=(_); end
  def failure_count; end
  def formatted_duration; end
  def formatted_load_time; end
  def fully_formatted(colorizer = T.unsafe(nil)); end
  def load_time; end
  def load_time=(_); end
  def pending_count; end
  def pending_examples; end
  def pending_examples=(_); end
  def totals_line; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module RSpec::Core::Ordering; end

class RSpec::Core::Ordering::ConfigurationManager
  def initialize; end

  def force(hash); end
  def order=(type); end
  def ordering_registry; end
  def register_ordering(name, strategy = T.unsafe(nil)); end
  def seed; end
  def seed=(seed); end
  def seed_used?; end
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end
  def shuffle(list, rng); end
  def used?; end
end

class RSpec::Core::Ordering::Registry
  def initialize(configuration); end

  def fetch(name, &fallback); end
  def register(sym, strategy); end
  def used_random_seed?; end
end

class RSpec::Core::Parser
  def parse(args); end
  def parser(options); end

  class << self
    def parse(args); end
  end
end

module RSpec::Core::Pending
  def pending(message = T.unsafe(nil)); end
  def skip(message = T.unsafe(nil)); end

  class << self
    def mark_fixed!(example); end
    def mark_pending!(example, message_or_bool); end
    def mark_skipped!(example, message_or_bool); end
  end
end

RSpec::Core::Pending::NOT_YET_IMPLEMENTED = T.let(T.unsafe(nil), String)
RSpec::Core::Pending::NO_REASON_GIVEN = T.let(T.unsafe(nil), String)
class RSpec::Core::Pending::PendingExampleFixedError < ::StandardError; end

class RSpec::Core::Pending::SkipDeclaredInExample < ::StandardError
  def initialize(argument); end

  def argument; end
end

RSpec::Core::RandomNumberGenerator = Random

class RSpec::Core::Reporter
  def initialize(configuration); end

  def deprecation(hash); end
  def example_failed(example); end
  def example_group_finished(group); end
  def example_group_started(group); end
  def example_passed(example); end
  def example_pending(example); end
  def example_started(example); end
  def examples; end
  def failed_examples; end
  def finish; end
  def message(message); end
  def notify(event, notification); end
  def pending_examples; end
  def register_listener(listener, *notifications); end
  def registered_listeners(notification); end
  def report(expected_example_count); end
  def start(expected_example_count, time = T.unsafe(nil)); end
  def stop; end

  private

  def mute_profile_output?; end
  def seed_used?; end
end

module RSpec::Core::RubyProject
  private

  def add_dir_to_load_path(dir); end
  def add_to_load_path(*dirs); end
  def ascend_until; end
  def determine_root; end
  def find_first_parent_containing(dir); end
  def root; end

  class << self
    def add_dir_to_load_path(dir); end
    def add_to_load_path(*dirs); end
    def ascend_until; end
    def determine_root; end
    def find_first_parent_containing(dir); end
    def root; end
  end
end

class RSpec::Core::Runner
  def initialize(options, configuration = T.unsafe(nil), world = T.unsafe(nil)); end

  def run(err, out); end
  def run_specs(example_groups); end
  def setup(err, out); end

  class << self
    def autorun; end
    def autorun_disabled?; end
    def disable_autorun!; end
    def installed_at_exit?; end
    def invoke; end
    def run(args, err = T.unsafe(nil), out = T.unsafe(nil)); end
    def running_in_drb?; end
    def trap_interrupt; end
  end
end

module RSpec::Core::SharedContext
  def __shared_context_recordings; end
  def after(*args, &block); end
  def append_after(*args, &block); end
  def append_before(*args, &block); end
  def around(*args, &block); end
  def before(*args, &block); end
  def context(*args, &block); end
  def describe(*args, &block); end
  def hooks(*args, &block); end
  def included(group); end
  def let(*args, &block); end
  def let!(*args, &block); end
  def prepend_after(*args, &block); end
  def prepend_before(*args, &block); end
  def subject(*args, &block); end
  def subject!(*args, &block); end

  class << self
    def record(methods); end
  end
end

class RSpec::Core::SharedContext::Recording < ::Struct
  def args; end
  def args=(_); end
  def block; end
  def block=(_); end
  def method_name; end
  def method_name=(_); end
  def playback_onto(group); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end
  def shared_examples(name, *args, &block); end
  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end
  def find(lookup_contexts, name); end

  private

  def ensure_block_has_source_location(_block); end
  def formatted_location(block); end
  def shared_example_groups; end
  def valid_name?(candidate); end
  def warn_if_key_taken(context, key, new_block); end
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  class << self
    def definitions; end
    def expose_globally!; end
    def exposed_globally?; end
    def remove_globally!; end
  end
end

class RSpec::Core::SuiteHookContext < ::RSpec::Core::Example
  def initialize; end

  def set_exception(exception, _context = T.unsafe(nil)); end
end

class RSpec::Core::Time
  class << self
    def now(in: T.unsafe(nil)); end
  end
end

module RSpec::Core::Version; end
RSpec::Core::Version::STRING = T.let(T.unsafe(nil), String)

module RSpec::Core::Warnings
  def deprecate(deprecated, data = T.unsafe(nil)); end
  def warn_deprecation(message, opts = T.unsafe(nil)); end
  def warn_with(message, options = T.unsafe(nil)); end
end

class RSpec::Core::World
  include ::RSpec::Core::Hooks

  def initialize(configuration = T.unsafe(nil)); end

  def announce_exclusion_filter(announcements); end
  def announce_filters; end
  def announce_inclusion_filter(announcements); end
  def clear_remaining_example_groups; end
  def configure_group(group); end
  def everything_filtered_message; end
  def example_count(groups = T.unsafe(nil)); end
  def example_groups; end
  def exclusion_filter; end
  def filter_manager; end
  def filtered_examples; end
  def inclusion_filter; end
  def ordered_example_groups; end
  def preceding_declaration_line(filter_line); end
  def register(example_group); end
  def reporter; end
  def reset; end
  def shared_example_group_registry; end
  def wants_to_quit; end
  def wants_to_quit=(_arg0); end
  def windows_os?; end

  private

  def declaration_line_numbers; end
end

module RSpec::ExampleGroups
  extend ::RSpec::Support::RecursiveConstMethods

  class << self
    def assign_const(group); end
    def base_name_for(group); end
    def constant_scope_for(group); end
    def disambiguate(name, const_scope); end
  end
end

RSpec::MODULES_TO_AUTOLOAD = T.let(T.unsafe(nil), Hash)
RSpec::SharedContext = RSpec::Core::SharedContext
