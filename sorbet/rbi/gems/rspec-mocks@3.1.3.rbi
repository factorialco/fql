# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rspec-mocks` gem.
# Please instead update this file by running `bin/tapioca gem rspec-mocks`.

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings

  class << self
    def configuration; end
    def configure; end
    def const_missing(name); end
    def context(*args, &example_group_block); end
    def current_example; end
    def current_example=(example); end
    def describe(*args, &example_group_block); end
    def example_group(*args, &example_group_block); end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end
    def reset; end
    def shared_context(name, *args, &block); end
    def shared_examples(name, *args, &block); end
    def shared_examples_for(name, *args, &block); end
    def thread_local_metadata; end
    def world; end
    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
  end
end

RSpec::MODULES_TO_AUTOLOAD = T.let(T.unsafe(nil), Hash)

module RSpec::Mocks
  class << self
    def allow_message(subject, message, opts = T.unsafe(nil), &block); end
    def configuration; end
    def expect_message(subject, message, opts = T.unsafe(nil), &block); end
    def setup; end
    def space; end
    def teardown; end
    def verify; end
    def with_temporary_scope; end
  end
end

class RSpec::Mocks::AllowanceTarget < ::RSpec::Mocks::TargetBase
  def not_to(matcher, *_args); end
  def to(matcher, &block); end
  def to_not(matcher, *_args); end
end

RSpec::Mocks::AllowanceTarget::EXPRESSION = T.let(T.unsafe(nil), Symbol)

class RSpec::Mocks::AndReturnImplementation
  def initialize(values_to_return); end

  def call(*_args_to_ignore, &_block); end
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def initialize(method, block); end

  def call(*args, &block); end
  def initial_action=(_value); end
  def inner_action; end
  def inner_action=(_value); end
  def present?; end
  def terminal_action=(_value); end

  private

  def cannot_modify_further_error; end
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError < ::StandardError; end

class RSpec::Mocks::AndYieldImplementation
  def initialize(args_to_yield, eval_context, error_generator); end

  def call(*_args_to_ignore, &block); end
end

module RSpec::Mocks::AnyInstance; end

class RSpec::Mocks::AnyInstance::Chain
  include ::RSpec::Mocks::AnyInstance::Chain::Customizations

  def initialize(recorder, *args, &block); end

  def constrained_to_any_of?(*constraints); end
  def expectation_fulfilled!; end
  def matches_args?(*args); end
  def never; end
  def playback!(instance); end
  def with(*args, &block); end

  private

  def last_message; end
  def messages; end
  def negated?; end
  def record(rspec_method_name, *args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end
  def and_raise(*args, &block); end
  def and_return(*args, &block); end
  def and_throw(*args, &block); end
  def and_yield(*args, &block); end
  def at_least(*args, &block); end
  def at_most(*args, &block); end
  def exactly(*args, &block); end
  def never(*args, &block); end
  def once(*args, &block); end
  def thrice(*args, &block); end
  def times(*args, &block); end
  def twice(*args, &block); end
  def with(*args, &block); end

  class << self
    def record(method_name); end
  end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain < ::RSpec::Mocks::AnyInstance::StubChain
  def initialize(*args); end

  def expectation_fulfilled?; end
  def playback!(instance); end

  private

  def create_message_expectation_on(instance); end
  def invocation_order; end
end

class RSpec::Mocks::AnyInstance::ExpectationChain < ::RSpec::Mocks::AnyInstance::Chain
  def initialize(*args, &block); end

  def expectation_fulfilled?; end

  private

  def verify_invocation_order(_rspec_method_name, *_args, &_block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end

  private

  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
end

class RSpec::Mocks::AnyInstance::MessageChains
  def initialize; end

  def [](method_name); end
  def add(method_name, chain); end
  def all_expectations_fulfilled?; end
  def each_unfulfilled_expectation_matching(method_name, *args); end
  def has_expectation?(method_name); end
  def playback!(instance, method_name); end
  def received_expected_message!(method_name); end
  def remove_stub_chains_for!(method_name); end
  def unfulfilled_expectations; end

  private

  def raise_if_second_instance_to_receive_message(instance); end
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain < ::RSpec::Mocks::AnyInstance::ExpectationChain
  private

  def create_message_expectation_on(instance); end
  def invocation_order; end
end

class RSpec::Mocks::AnyInstance::Proxy
  def initialize(recorder, target_proxies); end

  def expect_chain(*chain, &block); end
  def klass; end
  def should_not_receive(method_name, &block); end
  def should_receive(method_name, &block); end
  def stub(method_name_or_method_map, &block); end
  def stub_chain(*chain, &block); end
  def unstub(method_name); end

  private

  def perform_proxying(method_name, args, block, &target_proxy_block); end
end

class RSpec::Mocks::AnyInstance::Recorder
  def initialize(klass); end

  def already_observing?(method_name); end
  def build_alias_method_name(method_name); end
  def expect_chain(*method_names_and_optional_return_values, &block); end
  def instance_that_received(method_name); end
  def klass; end
  def message_chains; end
  def notify_received_message(_object, message, args, _blk); end
  def playback!(instance, method_name); end
  def should_not_receive(method_name, &block); end
  def should_receive(method_name, &block); end
  def stop_all_observation!; end
  def stub(method_name, &block); end
  def stub_chain(*method_names_and_optional_return_values, &block); end
  def stubs; end
  def unstub(method_name); end
  def verify; end

  protected

  def stop_observing!(method_name); end

  private

  def allow_no_prepended_module_definition_of(method_name); end
  def ancestor_is_an_observer?(method_name); end
  def backup_method!(method_name); end
  def mark_invoked!(method_name); end
  def normalize_chain(*args); end
  def observe!(method_name); end
  def public_protected_or_private_method_defined?(method_name); end
  def received_expected_message!(method_name); end
  def remove_dummy_method!(method_name); end
  def restore_method!(method_name); end
  def restore_original_method!(method_name); end
  def super_class_observers_for(method_name); end
  def super_class_observing?(method_name); end
end

class RSpec::Mocks::AnyInstance::StubChain < ::RSpec::Mocks::AnyInstance::Chain
  def expectation_fulfilled?; end

  private

  def create_message_expectation_on(instance); end
  def invocation_order; end
  def verify_invocation_order(rspec_method_name, *_args, &_block); end
end

class RSpec::Mocks::AnyInstance::StubChainChain < ::RSpec::Mocks::AnyInstance::StubChain
  def initialize(*args); end

  private

  def create_message_expectation_on(instance); end
  def invocation_order; end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget < ::RSpec::Mocks::TargetBase
  def not_to(matcher, *_args); end
  def to(matcher, &block); end
  def to_not(matcher, *_args); end
end

RSpec::Mocks::AnyInstanceAllowanceTarget::EXPRESSION = T.let(T.unsafe(nil), Symbol)

class RSpec::Mocks::AnyInstanceExpectationTarget < ::RSpec::Mocks::TargetBase
  def not_to(matcher, &block); end
  def to(matcher, &block); end
  def to_not(matcher, &block); end
end

RSpec::Mocks::AnyInstanceExpectationTarget::EXPRESSION = T.let(T.unsafe(nil), Symbol)

class RSpec::Mocks::ArgumentListMatcher
  def initialize(*expected_args); end

  def args_match?(*args); end
  def expected_args; end
end

RSpec::Mocks::ArgumentListMatcher::MATCH_ALL = T.let(T.unsafe(nil), RSpec::Mocks::ArgumentListMatcher)

module RSpec::Mocks::ArgumentMatchers
  def a_kind_of(klass); end
  def an_instance_of(klass); end
  def any_args; end
  def anything; end
  def array_including(*args); end
  def boolean; end
  def duck_type(*args); end
  def hash_excluding(*args); end
  def hash_including(*args); end
  def hash_not_including(*args); end
  def instance_of(klass); end
  def kind_of(klass); end
  def no_args; end

  class << self
    def anythingize_lonely_keys(*args); end
  end
end

class RSpec::Mocks::ArgumentMatchers::AnyArgMatcher
  def ===(_other); end
  def description; end
end

class RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher
  def description; end
end

class RSpec::Mocks::ArgumentMatchers::ArrayIncludingMatcher
  def initialize(expected); end

  def ===(actual); end
  def description; end
end

class RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
  def initialize(expected); end

  def ===(predicate, actual); end
  def description(name); end
end

class RSpec::Mocks::ArgumentMatchers::BooleanMatcher
  def ===(value); end
  def description; end
end

class RSpec::Mocks::ArgumentMatchers::DuckTypeMatcher
  def initialize(*methods_to_respond_to); end

  def ===(value); end
  def description; end
end

class RSpec::Mocks::ArgumentMatchers::HashExcludingMatcher < ::RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
  def ===(actual); end
  def description; end
end

class RSpec::Mocks::ArgumentMatchers::HashIncludingMatcher < ::RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
  def ===(actual); end
  def description; end
end

class RSpec::Mocks::ArgumentMatchers::InstanceOf
  def initialize(klass); end

  def ===(actual); end
  def description; end
end

class RSpec::Mocks::ArgumentMatchers::KindOf
  def initialize(klass); end

  def ===(actual); end
  def description; end
end

class RSpec::Mocks::ArgumentMatchers::NoArgsMatcher
  def description; end
end

class RSpec::Mocks::ClassVerifyingDouble < ::Module
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
end

class RSpec::Mocks::Configuration
  def initialize; end

  def add_stub_and_should_receive_to(*modules); end
  def patch_marshal_to_support_partial_doubles=(val); end
  def reset_syntaxes_to_default; end
  def syntax; end
  def syntax=(*values); end
  def transfer_nested_constants=(_arg0); end
  def transfer_nested_constants?; end
  def verify_doubled_constant_names=(_arg0); end
  def verify_doubled_constant_names?; end
  def verify_partial_doubles=(val); end
  def verify_partial_doubles?; end
  def yield_receiver_to_any_instance_implementation_blocks=(_arg0); end
  def yield_receiver_to_any_instance_implementation_blocks?; end
end

class RSpec::Mocks::Constant
  extend ::RSpec::Support::RecursiveConstMethods

  def initialize(name); end

  def hidden=(_arg0); end
  def hidden?; end
  def inspect; end
  def mutated?; end
  def name; end
  def original_value; end
  def original_value=(_arg0); end
  def previously_defined=(_arg0); end
  def previously_defined?; end
  def stubbed=(_arg0); end
  def stubbed?; end
  def to_s; end

  class << self
    def original(name); end
    def unmutated(name); end
  end
end

class RSpec::Mocks::ConstantMutator
  extend ::RSpec::Support::RecursiveConstMethods

  class << self
    def hide(constant_name); end
    def mutate(mutator); end
    def raise_on_invalid_const; end
    def stub(constant_name, value, options = T.unsafe(nil)); end
  end
end

class RSpec::Mocks::ConstantMutator::BaseMutator
  include ::RSpec::Support::RecursiveConstMethods

  def initialize(full_constant_name, mutated_value, transfer_nested_constants); end

  def full_constant_name; end
  def idempotently_reset; end
  def original_value; end
  def to_constant; end
end

class RSpec::Mocks::ConstantMutator::ConstantHider < ::RSpec::Mocks::ConstantMutator::BaseMutator
  def mutate; end
  def reset; end
  def to_constant; end
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer < ::RSpec::Mocks::ConstantMutator::BaseMutator
  def initialize(*args); end

  def mutate; end
  def reset; end
  def should_transfer_nested_constants?; end
  def to_constant; end
  def transfer_nested_constants; end
  def verify_constants_to_transfer!; end
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter < ::RSpec::Mocks::ConstantMutator::BaseMutator
  def mutate; end
  def reset; end
  def to_constant; end

  private

  def name_for(parent, name); end
end

class RSpec::Mocks::DirectModuleReference < ::RSpec::Mocks::DirectObjectReference
  def const_to_replace; end
  def description; end
end

class RSpec::Mocks::DirectObjectReference
  def initialize(object); end

  def const_to_replace; end
  def defined?; end
  def description; end
  def when_loaded; end
end

class RSpec::Mocks::Double
  include ::RSpec::Mocks::TestDouble
end

class RSpec::Mocks::ErrorGenerator
  def initialize(target, name); end

  def actual_method_call_args_description(count, args); end
  def describe_expectation(message, expected_received_count, _actual_received_count, *args); end
  def expected_method_call_args_description(args); end
  def expected_part_of_expectation_error(expected_received_count, expectation_count_type, argument_list_matcher); end
  def method_call_args_description(args); end
  def opts; end
  def opts=(_arg0); end
  def raise_block_failed_error(message, detail); end
  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, *args); end
  def raise_expectation_on_mocked_method(method); end
  def raise_expectation_on_unstubbed_method(method); end
  def raise_expired_test_double_error; end
  def raise_invalid_arguments_error(verifier); end
  def raise_missing_block_error(args_to_yield); end
  def raise_missing_default_stub_error(expectation, *args); end
  def raise_non_public_error(method_name, visibility); end
  def raise_only_valid_on_a_partial_double(method); end
  def raise_out_of_order_error(message); end
  def raise_similar_message_args_error(expectation, *args_for_multiple_calls); end
  def raise_unexpected_message_args_error(expectation, *args); end
  def raise_unexpected_message_error(message, *args); end
  def raise_unimplemented_error(doubled_module, method_name); end
  def raise_wrong_arity_error(args_to_yield, signature); end
  def received_part_of_expectation_error(actual_received_count, *args); end

  private

  def __raise(message); end
  def arg_has_valid_description(arg); end
  def arg_list(*args); end
  def arg_message(*args); end
  def count_message(count, expectation_count_type = T.unsafe(nil)); end
  def format_args(*args); end
  def format_received_args(*args); end
  def intro; end
  def received_arg_list(*args); end
  def times(count); end

  class << self
    def raise_double_negation_error(wrapped_expression); end
  end
end

module RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost

  def allow(target); end
  def allow_any_instance_of(klass); end
  def allow_message_expectations_on_nil; end
  def class_double(doubled_class, *args); end
  def class_spy(*args); end
  def double(*args); end
  def expect_any_instance_of(klass); end
  def have_received(method_name, &block); end
  def hide_const(constant_name); end
  def instance_double(doubled_class, *args); end
  def instance_spy(*args); end
  def object_double(object_or_name, *args); end
  def object_spy(*args); end
  def receive(method_name, &block); end
  def receive_message_chain(*messages, &block); end
  def receive_messages(message_return_value_hash); end
  def spy(*args); end
  def stub_const(constant_name, value, options = T.unsafe(nil)); end

  class << self
    def declare_double(type, *args); end
    def declare_verifying_double(type, ref, *args); end
    def included(klass); end
  end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

class RSpec::Mocks::ExpectChain < ::RSpec::Mocks::MessageChain
  private

  def expectation(object, message, &return_block); end

  class << self
    def expect_chain_on(object, *chain, &blk); end
  end
end

class RSpec::Mocks::ExpectationTarget < ::RSpec::Mocks::TargetBase
  def not_to(matcher, &block); end
  def to(matcher, &block); end
  def to_not(matcher, &block); end
end

RSpec::Mocks::ExpectationTarget::EXPRESSION = T.let(T.unsafe(nil), Symbol)
class RSpec::Mocks::ExpiredTestDoubleError < ::RSpec::Mocks::MockExpectationError; end
RSpec::Mocks::IGNORED_BACKTRACE_LINE = T.let(T.unsafe(nil), String)

class RSpec::Mocks::Implementation
  def call(*args, &block); end
  def initial_action; end
  def initial_action=(_arg0); end
  def inner_action; end
  def inner_action=(_arg0); end
  def present?; end
  def terminal_action; end
  def terminal_action=(_arg0); end

  private

  def actions; end
end

class RSpec::Mocks::InsertOntoBacktrace
  class << self
    def line(location); end
  end
end

class RSpec::Mocks::InstanceMethodReference < ::RSpec::Mocks::MethodReference
  private

  def find_method(mod); end
  def method_defined?(mod); end
  def method_implemented?(mod); end
  def visibility_from(mod); end
end

class RSpec::Mocks::InstanceMethodStasher
  def initialize(object, method); end

  def handle_restoration_failures; end
  def method_is_stashed?; end
  def original_method; end
  def restore; end
  def stash; end

  private

  def method_defined_directly_on_klass?; end
  def method_defined_on_klass?(klass = T.unsafe(nil)); end
  def method_owned_by_klass?; end
end

class RSpec::Mocks::InstanceVerifyingDouble
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble

  def initialize(doubled_module, *args); end

  def __build_mock_proxy(order_group); end
end

class RSpec::Mocks::MarshalExtension
  class << self
    def patch!; end
    def unpatch!; end
  end
end

module RSpec::Mocks::Matchers; end

class RSpec::Mocks::Matchers::ExpectationCustomization
  def initialize(method_name, args, block); end

  def block; end
  def block=(_arg0); end
  def playback_onto(expectation); end
end

class RSpec::Mocks::Matchers::HaveReceived
  def initialize(method_name, &block); end

  def at_least(*args); end
  def at_most(*args); end
  def description; end
  def does_not_match?(subject); end
  def exactly(*args); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(subject, &block); end
  def name; end
  def once(*args); end
  def ordered(*args); end
  def setup_allowance(_subject, &_block); end
  def setup_any_instance_allowance(_subject, &_block); end
  def setup_any_instance_expectation(_subject, &_block); end
  def thrice(*args); end
  def times(*args); end
  def twice(*args); end
  def with(*args); end

  private

  def apply_constraints_to(expectation); end
  def count_constraint; end
  def disallow(type, reason = T.unsafe(nil)); end
  def ensure_count_unconstrained; end
  def expect; end
  def expected_messages_received_in_order?; end
  def generate_failure_message; end
  def mock_proxy; end
end

RSpec::Mocks::Matchers::HaveReceived::ARGS_CONSTRAINTS = T.let(T.unsafe(nil), Array)
RSpec::Mocks::Matchers::HaveReceived::CONSTRAINTS = T.let(T.unsafe(nil), Array)
RSpec::Mocks::Matchers::HaveReceived::COUNT_CONSTRAINTS = T.let(T.unsafe(nil), Array)

class RSpec::Mocks::Matchers::Receive
  def initialize(message, block); end

  def actual_received_count_matters?(*args, &block); end
  def additional_expected_calls(*args, &block); end
  def advise(*args, &block); end
  def and_call_original(*args, &block); end
  def and_raise(*args, &block); end
  def and_return(*args, &block); end
  def and_throw(*args, &block); end
  def and_wrap_original(*args, &block); end
  def and_yield(*args, &block); end
  def and_yield_receiver_to_implementation(*args, &block); end
  def argument_list_matcher=(*args, &block); end
  def at_least(*args, &block); end
  def at_most(*args, &block); end
  def called_max_times?(*args, &block); end
  def description(*args, &block); end
  def does_not_match?(subject, &block); end
  def ensure_expected_ordering_received!(*args, &block); end
  def exactly(*args, &block); end
  def expectation_count_type(*args, &block); end
  def expected_args(*args, &block); end
  def expected_messages_received?(*args, &block); end
  def generate_error(*args, &block); end
  def ignoring_args?(*args, &block); end
  def implementation(*args, &block); end
  def increase_actual_received_count!(*args, &block); end
  def invoke(*args, &block); end
  def invoke_without_incrementing_received_count(*args, &block); end
  def matches?(subject, &block); end
  def matches_at_least_count?(*args, &block); end
  def matches_at_most_count?(*args, &block); end
  def matches_exact_count?(*args, &block); end
  def matches_name_but_not_args(*args, &block); end
  def message(*args, &block); end
  def name; end
  def negative?(*args, &block); end
  def negative_expectation_for?(*args, &block); end
  def never(*args, &block); end
  def once(*args, &block); end
  def ordered(*args, &block); end
  def ordered?(*args, &block); end
  def orig_object(*args, &block); end
  def raise_out_of_order_error(*args, &block); end
  def safe_invoke(*args, &block); end
  def setup_allowance(subject, &block); end
  def setup_any_instance_allowance(subject, &block); end
  def setup_any_instance_expectation(subject, &block); end
  def setup_any_instance_negative_expectation(subject, &block); end
  def setup_expectation(subject, &block); end
  def setup_negative_expectation(subject, &block); end
  def similar_messages(*args, &block); end
  def thrice(*args, &block); end
  def times(*args, &block); end
  def twice(*args, &block); end
  def verify_messages_received(*args, &block); end
  def with(*args, &block); end
  def yield_receiver_to_implementation_block?(*args, &block); end

  private

  def move_block_to_last_customization(block); end
  def setup_any_instance_method_substitute(subject, method, block); end
  def setup_method_substitute(host, method, block, *args); end
  def setup_mock_proxy_method_substitute(subject, method, block); end
  def warn_if_any_instance(expression, subject); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  def initialize(chain, &block); end

  def and_call_original(*args, &block); end
  def and_raise(*args, &block); end
  def and_return(*args, &block); end
  def and_throw(*args, &block); end
  def and_yield(*args, &block); end
  def does_not_match?(*_args); end
  def matches?(subject, &block); end
  def name; end
  def setup_allowance(subject, &block); end
  def setup_any_instance_allowance(subject, &block); end
  def setup_any_instance_expectation(subject, &block); end
  def setup_expectation(subject, &block); end
  def setup_negative_expectation(*_args); end
  def with(*args, &block); end

  private

  def replay_customizations(chain); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
  def initialize(message_return_value_hash); end

  def does_not_match?(_subject); end
  def matches?(subject); end
  def name; end
  def setup_allowance(subject); end
  def setup_any_instance_allowance(subject); end
  def setup_any_instance_expectation(subject); end
  def setup_expectation(subject); end
  def setup_negative_expectation(_subject); end
  def warn_about_block; end

  private

  def any_instance_of(subject); end
  def each_message_on(host); end
  def proxy_on(subject); end
end

class RSpec::Mocks::MessageChain
  def initialize(object, *chain, &blk); end

  def block; end
  def chain; end
  def object; end
  def setup_chain; end

  private

  def chain_on(object, *chain, &block); end
  def expectation(_object, _message, &_return_block); end
  def find_matching_expectation; end
  def find_matching_stub; end
  def format_chain(*chain, &blk); end
end

class RSpec::Mocks::MessageExpectation
  def initialize(error_generator, expectation_ordering, expected_from, method_double, type = T.unsafe(nil), opts = T.unsafe(nil), &implementation_block); end

  def actual_received_count_matters?; end
  def additional_expected_calls; end
  def advise(*args); end
  def and_call_original; end
  def and_raise(exception = T.unsafe(nil), message = T.unsafe(nil)); end
  def and_return(first_value, *values); end
  def and_throw(*args); end
  def and_wrap_original(&block); end
  def and_yield(*args, &block); end
  def and_yield_receiver_to_implementation; end
  def argument_list_matcher=(_arg0); end
  def at_least(n, &block); end
  def at_most(n, &block); end
  def called_max_times?; end
  def description; end
  def ensure_expected_ordering_received!; end
  def exactly(n, &block); end
  def expectation_count_type; end
  def expected_args; end
  def expected_messages_received?; end
  def generate_error; end
  def ignoring_args?; end
  def implementation; end
  def increase_actual_received_count!; end
  def invoke(parent_stub, *args, &block); end
  def invoke_without_incrementing_received_count(parent_stub, *args, &block); end
  def matches?(message, *args); end
  def matches_at_least_count?; end
  def matches_at_most_count?; end
  def matches_exact_count?; end
  def matches_name_but_not_args(message, *args); end
  def message; end
  def negative?; end
  def negative_expectation_for?(message); end
  def never; end
  def once(&block); end
  def ordered(&block); end
  def ordered?; end
  def orig_object; end
  def raise_out_of_order_error; end
  def safe_invoke(parent_stub, *args, &block); end
  def similar_messages; end
  def thrice(&block); end
  def times(&block); end
  def twice(&block); end
  def verify_messages_received; end
  def with(*args, &block); end
  def yield_receiver_to_implementation_block?; end

  protected

  def error_generator; end
  def error_generator=(_arg0); end
  def expected_from=(_arg0); end
  def expected_received_count=(_arg0); end
  def implementation=(_arg0); end

  private

  def failed_fast?; end
  def initial_implementation_action=(action); end
  def inner_implementation_action=(action); end
  def invoke_incrementing_actual_calls_by(increment, allowed_to_fail, parent_stub, *args, &block); end
  def set_expected_received_count(relativity, n); end
  def terminal_implementation_action=(action); end
  def warn_about_stub_override; end
end

class RSpec::Mocks::MethodDouble
  def initialize(object, method_name, proxy); end

  def add_default_stub(*args, &implementation); end
  def add_expectation(error_generator, expectation_ordering, expected_from, opts, &implementation); end
  def add_simple_expectation(method_name, response, error_generator, backtrace_line); end
  def add_simple_stub(method_name, response); end
  def add_stub(error_generator, expectation_ordering, expected_from, opts = T.unsafe(nil), &implementation); end
  def build_expectation(error_generator, expectation_ordering); end
  def clear; end
  def configure_method; end
  def define_proxy_method; end
  def expectations; end
  def message_expectation_class; end
  def method_name; end
  def object; end
  def object_singleton_class; end
  def original_method; end
  def proxy_method_invoked(_obj, *args, &block); end
  def raise_method_not_stubbed_error; end
  def remove_stub; end
  def remove_stub_if_present; end
  def reset; end
  def restore_original_method; end
  def restore_original_visibility; end
  def save_original_method!; end
  def setup_simple_method_double(method_name, response, collection, error_generator = T.unsafe(nil), backtrace_line = T.unsafe(nil)); end
  def show_frozen_warning; end
  def stubs; end
  def verify; end
  def visibility; end

  private

  def definition_target; end
  def new_rspec_prepended_module; end
  def usable_rspec_prepended_module; end
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule < ::Module; end

class RSpec::Mocks::MethodReference
  def initialize(object_reference, method_name); end

  def defined?; end
  def implemented?; end
  def unimplemented?; end
  def visibility; end
  def with_signature; end

  private

  def original_method; end

  class << self
    def instance_method_visibility_for(klass, method_name); end
    def method_defined_at_any_visibility?(klass, method_name); end
    def method_visibility_for(object, method_name); end
  end
end

class RSpec::Mocks::MockExpectationError < ::Exception; end

class RSpec::Mocks::NamedObjectReference
  def initialize(const_name); end

  def const_to_replace; end
  def defined?; end
  def description; end
  def when_loaded(&_block); end

  private

  def object; end
end

class RSpec::Mocks::NegationUnsupportedError < ::StandardError; end

class RSpec::Mocks::NestedSpace < ::RSpec::Mocks::Space
  def initialize(parent); end

  def constant_mutator_for(name); end
  def proxies_of(klass); end
  def registered?(object); end

  private

  def any_instance_recorder_not_found_for(id, klass); end
  def proxy_not_found_for(id, object); end
end

class RSpec::Mocks::ObjectMethodReference < ::RSpec::Mocks::MethodReference
  private

  def find_method(object); end
  def method_defined?(object); end
  def method_implemented?(object); end
  def visibility_from(object); end
end

class RSpec::Mocks::ObjectReference
  class << self
    def for(object_module_or_name, allow_direct_object_refs = T.unsafe(nil)); end
  end
end

class RSpec::Mocks::ObjectVerifyingDouble
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble

  def initialize(doubled_module, *args); end

  def as_stubbed_const(options = T.unsafe(nil)); end

  private

  def __build_mock_proxy(order_group); end
end

class RSpec::Mocks::OrderGroup
  def initialize; end

  def clear; end
  def consume; end
  def empty?; end
  def handle_order_constraint(expectation); end
  def invoked(message); end
  def ready_for?(expectation); end
  def register(expectation); end
  def verify_invocation_order(expectation); end

  private

  def expectation_for(message); end
  def expectations_invoked_in_order?; end
  def expected_invocations; end
  def invoked_expectations; end
  def remaining_expectations; end
end

class RSpec::Mocks::OutsideOfExampleError < ::StandardError; end

class RSpec::Mocks::PartialClassDoubleProxy < ::RSpec::Mocks::PartialDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  def initialize(source_space, *args); end

  def original_method_handle_for(message); end

  protected

  def original_unbound_method_handle_from_ancestor_for(message); end
  def superclass_proxy; end
end

class RSpec::Mocks::PartialDoubleProxy < ::RSpec::Mocks::Proxy
  def add_simple_expectation(method_name, response, location); end
  def add_simple_stub(method_name, response); end
  def message_received(message, *args, &block); end
  def original_method_handle_for(message); end
  def reset; end
  def visibility_for(method_name); end

  private

  def any_instance_class_recorder_observing_method?(klass, method_name); end
end

class RSpec::Mocks::Proxy
  def initialize(object, order_group, name = T.unsafe(nil), options = T.unsafe(nil)); end

  def add_message_expectation(method_name, opts = T.unsafe(nil), &block); end
  def add_simple_expectation(method_name, response, location); end
  def add_simple_stub(method_name, response); end
  def add_stub(method_name, opts = T.unsafe(nil), &implementation); end
  def as_null_object; end
  def build_expectation(method_name); end
  def check_for_unexpected_arguments(expectation); end
  def ensure_implemented(*_args); end
  def has_negative_expectation?(message); end
  def message_received(message, *args, &block); end
  def null_object?; end
  def object; end
  def original_method_handle_for(_message); end
  def prepended_modules_of_singleton_class; end
  def raise_missing_default_stub_error(expectation, *args); end
  def raise_unexpected_message_args_error(expectation, *args); end
  def raise_unexpected_message_error(method_name, *args); end
  def received_message?(method_name, *args, &block); end
  def record_message_received(message, *args, &block); end
  def remove_stub(method_name); end
  def remove_stub_if_present(method_name); end
  def replay_received_message_on(expectation, &block); end
  def reset; end
  def verify; end
  def visibility_for(_method_name); end

  private

  def find_almost_matching_expectation(method_name, *args); end
  def find_almost_matching_stub(method_name, *args); end
  def find_best_matching_expectation_for(method_name); end
  def find_matching_expectation(method_name, *args); end
  def find_matching_method_stub(method_name, *args); end
  def method_double_for(message); end

  class << self
    def prepended_modules_of(klass); end
  end
end

class RSpec::Mocks::Proxy::SpecificMessage < ::Struct
  def ==(expectation); end
  def args; end
  def args=(_); end
  def message; end
  def message=(_); end
  def object; end
  def object=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RSpec::Mocks::ProxyForNil < ::RSpec::Mocks::PartialDoubleProxy
  def initialize(order_group); end

  def add_message_expectation(method_name, opts = T.unsafe(nil), &block); end
  def add_negative_message_expectation(location, method_name, &implementation); end
  def add_stub(method_name, opts = T.unsafe(nil), &implementation); end
  def warn_about_expectations; end
  def warn_about_expectations=(_arg0); end
  def warn_about_expectations?; end

  private

  def warn(method_name); end
end

class RSpec::Mocks::RootSpace
  def any_instance_proxy_for(*_args); end
  def any_instance_recorder_for(*_args); end
  def any_instance_recorders_from_ancestry_of(_object); end
  def new_scope; end
  def proxy_for(*_args); end
  def register_constant_mutator(_mutator); end
  def registered?(_object); end
  def reset_all; end
  def verify_all; end

  private

  def raise_lifecycle_message; end
end

class RSpec::Mocks::SimpleMessageExpectation
  def initialize(message, response, error_generator, backtrace_line = T.unsafe(nil)); end

  def called_max_times?; end
  def invoke(*_); end
  def matches?(message, *_); end
  def verify_messages_received; end
end

class RSpec::Mocks::Space
  def initialize; end

  def any_instance_mutex; end
  def any_instance_proxy_for(klass); end
  def any_instance_recorder_for(klass, only_return_existing = T.unsafe(nil)); end
  def any_instance_recorders; end
  def any_instance_recorders_from_ancestry_of(object); end
  def constant_mutator_for(name); end
  def ensure_registered(object); end
  def new_scope; end
  def proxies; end
  def proxies_of(klass); end
  def proxy_for(object); end
  def proxy_mutex; end
  def register_constant_mutator(mutator); end
  def registered?(object); end
  def reset_all; end
  def verify_all; end

  private

  def any_instance_recorder_not_found_for(id, klass); end
  def id_for(object); end
  def new_mutex; end
  def proxy_not_found_for(id, object); end
end

module RSpec::Mocks::Space::FakeMutex
  class << self
    def synchronize; end
  end
end

class RSpec::Mocks::StubChain < ::RSpec::Mocks::MessageChain
  private

  def expectation(object, message, &return_block); end

  class << self
    def stub_chain_on(object, *chain, &blk); end
  end
end

module RSpec::Mocks::Syntax
  class << self
    def default_should_syntax_host; end
    def disable_expect(syntax_host = T.unsafe(nil)); end
    def disable_should(syntax_host = T.unsafe(nil)); end
    def enable_expect(syntax_host = T.unsafe(nil)); end
    def enable_should(syntax_host = T.unsafe(nil)); end
    def expect_enabled?(syntax_host = T.unsafe(nil)); end
    def should_enabled?(syntax_host = T.unsafe(nil)); end
    def warn_about_should!; end
    def warn_unless_should_configured(method_name, replacement = T.unsafe(nil)); end
  end
end

class RSpec::Mocks::TargetBase
  def initialize(target); end

  private

  def define_matcher(matcher, name, &block); end
  def expression; end
  def matcher_allowed?(matcher); end
  def raise_negation_unsupported(method_name, matcher); end
  def raise_unsupported_matcher(method_name, matcher); end

  class << self
    def delegate_not_to(matcher_method, options = T.unsafe(nil)); end
    def delegate_to(matcher_method); end
    def disallow_negation(method_name); end
  end
end

module RSpec::Mocks::TestDouble
  def initialize(name = T.unsafe(nil), stubs = T.unsafe(nil)); end

  def ==(other); end
  def __build_mock_proxy_unless_expired(order_group); end
  def __disallow_further_usage!; end
  def as_null_object; end
  def freeze; end
  def inspect; end
  def null_object?; end
  def respond_to?(message, incl_private = T.unsafe(nil)); end
  def to_s; end

  private

  def __build_mock_proxy(order_group); end
  def __mock_proxy; end
  def __raise_expired_error; end
  def assign_stubs(stubs); end
  def initialize_copy(other); end
  def method_missing(message, *args, &block); end
end

class RSpec::Mocks::TestDoubleProxy < ::RSpec::Mocks::Proxy
  def reset; end
end

class RSpec::Mocks::UnsupportedMatcherError < ::StandardError; end

module RSpec::Mocks::VerifyingDouble
  def initialize(*args); end

  def __send__(name, *args, &block); end
  def method_missing(message, *args, &block); end
  def respond_to?(message, include_private = T.unsafe(nil)); end
  def send(name, *args, &block); end
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError < ::StandardError; end

class RSpec::Mocks::VerifyingExistingMethodDouble < ::RSpec::Mocks::VerifyingMethodDouble
  def initialize(object, method_name, proxy); end

  def unimplemented?; end
  def with_signature; end
end

class RSpec::Mocks::VerifyingMessageExpectation < ::RSpec::Mocks::MessageExpectation
  def initialize(*args); end

  def method_reference; end
  def method_reference=(_arg0); end
  def with(*args, &block); end

  private

  def validate_expected_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingMethodDouble < ::RSpec::Mocks::MethodDouble
  def initialize(object, method_name, proxy, method_reference); end

  def add_expectation(*args, &block); end
  def add_stub(*args, &block); end
  def message_expectation_class; end
  def proxy_method_invoked(obj, *args, &block); end

  private

  def validate_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy < ::RSpec::Mocks::VerifyingPartialDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::VerifyingPartialDoubleProxy < ::RSpec::Mocks::PartialDoubleProxy
  include ::RSpec::Mocks::VerifyingProxyMethods

  def initialize(object, expectation_ordering); end

  def method_reference; end
end

class RSpec::Mocks::VerifyingProxy < ::RSpec::Mocks::TestDoubleProxy
  include ::RSpec::Mocks::VerifyingProxyMethods

  def initialize(object, order_group, name, doubled_module, method_reference_class); end

  def method_reference; end
  def visibility_for(method_name); end
end

module RSpec::Mocks::VerifyingProxyMethods
  def add_message_expectation(method_name, opts = T.unsafe(nil), &block); end
  def add_simple_stub(method_name, *args); end
  def add_stub(method_name, opts = T.unsafe(nil), &implementation); end
  def ensure_implemented(method_name); end
  def ensure_publicly_implemented(method_name, _object); end
end

module RSpec::Mocks::Version; end
RSpec::Mocks::Version::STRING = T.let(T.unsafe(nil), String)
RSpec::SharedContext = RSpec::Core::SharedContext
