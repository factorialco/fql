# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rspec-support` gem.
# Please instead update this file by running `bin/tapioca gem rspec-support`.

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings

  class << self
    def configuration; end
    def configure; end
    def const_missing(name); end
    def context(*args, &example_group_block); end
    def current_example; end
    def current_example=(example); end
    def describe(*args, &example_group_block); end
    def example_group(*args, &example_group_block); end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end
    def reset; end
    def shared_context(name, *args, &block); end
    def shared_examples(name, *args, &block); end
    def shared_examples_for(name, *args, &block); end
    def thread_local_metadata; end
    def world; end
    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
  end
end

class RSpec::CallerFilter
  class << self
    def first_non_rspec_line; end
  end
end

RSpec::CallerFilter::ADDITIONAL_TOP_LEVEL_FILES = T.let(T.unsafe(nil), Array)
RSpec::CallerFilter::IGNORE_REGEX = T.let(T.unsafe(nil), Regexp)
RSpec::CallerFilter::LIB_REGEX = T.let(T.unsafe(nil), Regexp)
RSpec::CallerFilter::RSPEC_LIBS = T.let(T.unsafe(nil), Array)
RSpec::MODULES_TO_AUTOLOAD = T.let(T.unsafe(nil), Hash)
RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  class << self
    def define_optimized_require_for_rspec(lib, &require_relative); end
    def deregister_matcher_definition(&block); end
    def is_a_matcher?(object); end
    def matcher_definitions; end
    def method_handle_for(object, method_name); end
    def register_matcher_definition(&block); end
    def require_rspec_core(f); end
    def require_rspec_expectations(f); end
    def require_rspec_matchers(f); end
    def require_rspec_mocks(f); end
    def require_rspec_support(f); end
  end
end

class RSpec::Support::BlockSignature < ::RSpec::Support::MethodSignature
  def classify_parameters; end
end

class RSpec::Support::Differ
  def initialize(opts = T.unsafe(nil)); end

  def color?; end
  def diff(actual, expected); end
  def diff_as_object(actual, expected); end
  def diff_as_string(actual, expected); end

  private

  def add_old_hunk_to_hunk(hunk, oldhunk); end
  def add_to_output(output, string); end
  def all_strings?(*args); end
  def any_multiline_strings?(*args); end
  def blue(text); end
  def coerce_to_string(string_or_array); end
  def color(text, color_code); end
  def color_diff(diff); end
  def diffably_stringify(array); end
  def finalize_output(output, final_line); end
  def format_type; end
  def green(text); end
  def handle_encoding_errors; end
  def hunks; end
  def multiline?(string); end
  def no_numbers?(*args); end
  def no_procs?(*args); end
  def normal(text); end
  def object_to_string(object); end
  def pick_encoding(source_a, source_b); end
  def red(text); end
  def safely_flatten(array); end
end

class RSpec::Support::DirectoryMaker
  class << self
    def mkdir_p(path); end

    private

    def directory_exists?(dirname); end
    def generate_path(stack, part); end
    def generate_stack(path); end
  end
end

class RSpec::Support::EncodedString
  def initialize(string, encoding = T.unsafe(nil)); end

  def <<(string); end
  def ==(*args, &block); end
  def empty?(*args, &block); end
  def encoding(*args, &block); end
  def eql?(*args, &block); end
  def lines(*args, &block); end
  def source_encoding; end
  def split(regex_or_string); end
  def to_s; end
  def to_str; end

  private

  def detect_source_encoding(string); end
  def matching_encoding(string); end
  def normalize_missing(string); end
end

RSpec::Support::EncodedString::MRI_UNICODE_UNKOWN_CHARACTER = T.let(T.unsafe(nil), String)

module RSpec::Support::FuzzyMatcher
  class << self
    def values_match?(expected, actual); end

    private

    def arrays_match?(expected_list, actual_list); end
    def hashes_match?(expected_hash, actual_hash); end
  end
end

class RSpec::Support::HunkGenerator
  def initialize(actual, expected); end

  def hunks; end

  private

  def actual_lines; end
  def build_hunk(piece); end
  def context_lines; end
  def diffs; end
  def expected_lines; end
end

RSpec::Support::KERNEL_METHOD_METHOD = T.let(T.unsafe(nil), UnboundMethod)

class RSpec::Support::LooseSignatureVerifier < ::RSpec::Support::MethodSignatureVerifier
  private

  def split_args(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def initialize(signature); end

  def has_kw_args_in?(args); end
  def invalid_kw_args_from(_kw_args); end
  def missing_kw_args_from(_kw_args); end
  def non_kw_args_arity_description; end
  def valid_non_kw_args?(*args); end
end

class RSpec::Support::MethodSignature
  def initialize(method); end

  def classify_parameters; end
  def could_contain_kw_args?(args); end
  def description; end
  def has_kw_args_in?(args); end
  def invalid_kw_args_from(given_kw_args); end
  def max_non_kw_args; end
  def min_non_kw_args; end
  def missing_kw_args_from(given_kw_args); end
  def non_kw_args_arity_description; end
  def valid_non_kw_args?(positional_arg_count); end
end

RSpec::Support::MethodSignature::INFINITY = T.let(T.unsafe(nil), Float)

class RSpec::Support::MethodSignatureVerifier
  def initialize(signature, args); end

  def error_message; end
  def kw_args; end
  def non_kw_args; end
  def valid?; end

  private

  def invalid_kw_args; end
  def missing_kw_args; end
  def split_args(*args); end
  def valid_non_kw_args?; end
end

module RSpec::Support::OS
  private

  def windows?; end
  def windows_file_path?; end

  class << self
    def windows?; end
    def windows_file_path?; end
  end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end
  def constants_defined_on(mod); end
  def get_const_defined_on(mod, const_name); end
  def normalize_const_name(const_name); end
  def recursive_const_defined?(const_name); end
  def recursive_const_get(const_name); end
end

module RSpec::Support::Ruby
  private

  def jruby?; end

  class << self
    def jruby?; end
  end
end

module RSpec::Support::RubyFeatures
  private

  def kw_args_supported?; end
  def module_prepends_supported?; end
  def optional_and_splat_args_supported?; end
  def required_kw_args_supported?; end
  def supports_rebinding_module_methods?; end

  class << self
    def kw_args_supported?; end
    def module_prepends_supported?; end
    def optional_and_splat_args_supported?; end
    def required_kw_args_supported?; end
    def supports_rebinding_module_methods?; end
  end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier
module RSpec::Support::Version; end
RSpec::Support::Version::STRING = T.let(T.unsafe(nil), String)

module RSpec::Support::Warnings
  def deprecate(deprecated, options = T.unsafe(nil)); end
  def warn_deprecation(message, options = T.unsafe(nil)); end
  def warn_with(message, options = T.unsafe(nil)); end
  def warning(text, options = T.unsafe(nil)); end
end
