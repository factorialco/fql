# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rspec-expectations` gem.
# Please instead update this file by running `bin/tapioca gem rspec-expectations`.

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings

  class << self
    def configuration; end
    def configure; end
    def const_missing(name); end
    def context(*args, &example_group_block); end
    def current_example; end
    def current_example=(example); end
    def describe(*args, &example_group_block); end
    def example_group(*args, &example_group_block); end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end
    def reset; end
    def shared_context(name, *args, &block); end
    def shared_examples(name, *args, &block); end
    def shared_examples_for(name, *args, &block); end
    def thread_local_metadata; end
    def world; end
    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
  end
end

module RSpec::Expectations
  class << self
    def configuration; end
    def differ; end
    def fail_with(message, expected = T.unsafe(nil), actual = T.unsafe(nil)); end
  end
end

class RSpec::Expectations::BlockExpectationTarget < ::RSpec::Expectations::ExpectationTarget
  def not_to(matcher, message = T.unsafe(nil), &block); end
  def to(matcher, message = T.unsafe(nil), &block); end
  def to_not(matcher, message = T.unsafe(nil), &block); end

  private

  def description_of(matcher); end
  def enforce_block_expectation(matcher); end
  def supports_block_expectations?(matcher); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end
  def backtrace_formatter; end
  def backtrace_formatter=(_arg0); end
  def color?; end
  def include_chain_clauses_in_custom_matcher_descriptions=(_arg0); end
  def include_chain_clauses_in_custom_matcher_descriptions?; end
  def reset_syntaxes_to_default; end
  def syntax; end
  def syntax=(values); end
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  class << self
    def format_backtrace(backtrace); end
  end
end

module RSpec::Expectations::ExpectationHelper
  class << self
    def check_message(msg); end
    def handle_failure(matcher, message, failure_message_method); end
    def modern_matcher_from(matcher); end
    def setup(handler, matcher, message); end
  end
end

class RSpec::Expectations::ExpectationNotMetError < ::Exception; end

class RSpec::Expectations::ExpectationTarget
  def initialize(value); end

  def not_to(matcher = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def to(matcher = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def to_not(matcher = T.unsafe(nil), message = T.unsafe(nil), &block); end

  private

  def prevent_operator_matchers(verb); end

  class << self
    def for(value, block); end
  end
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue; end
RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::LegacyMatcherAdapter < ::RSpec::Matchers::MatcherDelegator
  def initialize(matcher); end

  class << self
    def wrap(matcher); end
  end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1 < ::RSpec::Expectations::LegacyMatcherAdapter
  def failure_message; end
  def failure_message_when_negated; end

  class << self
    def interface_matches?(matcher); end
  end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2 < ::RSpec::Expectations::LegacyMatcherAdapter
  def failure_message; end
  def failure_message_when_negated; end

  class << self
    def interface_matches?(matcher); end
  end
end

class RSpec::Expectations::NegativeExpectationHandler
  class << self
    def does_not_match?(matcher, actual, &block); end
    def handle_matcher(actual, initial_matcher, message = T.unsafe(nil), &block); end
    def opposite_should_method; end
    def should_method; end
    def verb; end
  end
end

class RSpec::Expectations::PositiveExpectationHandler
  class << self
    def handle_matcher(actual, initial_matcher, message = T.unsafe(nil), &block); end
    def opposite_should_method; end
    def should_method; end
    def verb; end
  end
end

module RSpec::Expectations::Syntax
  private

  def default_should_host; end
  def disable_expect(syntax_host = T.unsafe(nil)); end
  def disable_should(syntax_host = T.unsafe(nil)); end
  def enable_expect(syntax_host = T.unsafe(nil)); end
  def enable_should(syntax_host = T.unsafe(nil)); end
  def expect_enabled?(syntax_host = T.unsafe(nil)); end
  def should_enabled?(syntax_host = T.unsafe(nil)); end
  def warn_about_should!; end
  def warn_about_should_unless_configured(method_name); end

  class << self
    def default_should_host; end
    def disable_expect(syntax_host = T.unsafe(nil)); end
    def disable_should(syntax_host = T.unsafe(nil)); end
    def enable_expect(syntax_host = T.unsafe(nil)); end
    def enable_should(syntax_host = T.unsafe(nil)); end
    def expect_enabled?(syntax_host = T.unsafe(nil)); end
    def should_enabled?(syntax_host = T.unsafe(nil)); end
    def warn_about_should!; end
    def warn_about_should_unless_configured(method_name); end
  end
end

module RSpec::Expectations::Version; end
RSpec::Expectations::Version::STRING = T.let(T.unsafe(nil), String)
RSpec::MODULES_TO_AUTOLOAD = T.let(T.unsafe(nil), Hash)

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL

  def a_block_changing(*args, &block); end
  def a_block_outputting(*args, &block); end
  def a_block_raising(*args, &block); end
  def a_block_throwing(*args, &block); end
  def a_block_yielding_control(*args, &block); end
  def a_block_yielding_successive_args(*args, &block); end
  def a_block_yielding_with_args(*args, &block); end
  def a_block_yielding_with_no_args(*args, &block); end
  def a_collection_containing_exactly(*args, &block); end
  def a_collection_ending_with(*args, &block); end
  def a_collection_including(*args, &block); end
  def a_collection_starting_with(*args, &block); end
  def a_falsey_value(*args, &block); end
  def a_falsy_value(*args, &block); end
  def a_hash_including(*args, &block); end
  def a_kind_of(*args, &block); end
  def a_nil_value(*args, &block); end
  def a_range_covering(*args, &block); end
  def a_string_ending_with(*args, &block); end
  def a_string_including(*args, &block); end
  def a_string_matching(*args, &block); end
  def a_string_starting_with(*args, &block); end
  def a_truthy_value(*args, &block); end
  def a_value(*args, &block); end
  def a_value_between(*args, &block); end
  def a_value_within(*args, &block); end
  def all(expected); end
  def an_instance_of(*args, &block); end
  def an_object_eq_to(*args, &block); end
  def an_object_eql_to(*args, &block); end
  def an_object_equal_to(*args, &block); end
  def an_object_existing(*args, &block); end
  def an_object_having_attributes(*args, &block); end
  def an_object_matching(*args, &block); end
  def an_object_responding_to(*args, &block); end
  def an_object_satisfying(*args, &block); end
  def be(*args); end
  def be_a(klass); end
  def be_a_kind_of(expected); end
  def be_an(klass); end
  def be_an_instance_of(expected); end
  def be_between(min, max); end
  def be_falsey; end
  def be_falsy(*args, &block); end
  def be_instance_of(expected); end
  def be_kind_of(expected); end
  def be_nil; end
  def be_truthy; end
  def be_within(delta); end
  def change(receiver = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def changing(*args, &block); end
  def contain_exactly(*items); end
  def containing_exactly(*args, &block); end
  def cover(*values); end
  def covering(*args, &block); end
  def end_with(*expected); end
  def ending_with(*args, &block); end
  def eq(expected); end
  def eq_to(*args, &block); end
  def eql(expected); end
  def eql_to(*args, &block); end
  def equal(expected); end
  def equal_to(*args, &block); end
  def exist(*args); end
  def existing(*args, &block); end
  def expect(value = T.unsafe(nil), &block); end
  def have_attributes(expected); end
  def include(*expected); end
  def including(*args, &block); end
  def match(expected); end
  def match_array(items); end
  def match_regex(*args, &block); end
  def matching(*args, &block); end
  def output(expected = T.unsafe(nil)); end
  def raise_error(error = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def raise_exception(error = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def raising(*args, &block); end
  def respond_to(*names); end
  def responding_to(*args, &block); end
  def satisfy(&block); end
  def satisfying(*args, &block); end
  def start_with(*expected); end
  def starting_with(*args, &block); end
  def throw_symbol(expected_symbol = T.unsafe(nil), expected_arg = T.unsafe(nil)); end
  def throwing(*args, &block); end
  def within(*args, &block); end
  def yield_control; end
  def yield_successive_args(*args); end
  def yield_with_args(*args); end
  def yield_with_no_args; end
  def yielding_control(*args, &block); end
  def yielding_successive_args(*args, &block); end
  def yielding_with_args(*args, &block); end
  def yielding_with_no_args(*args, &block); end

  private

  def method_missing(method, *args, &block); end

  class << self
    def alias_matcher(new_name, old_name, options = T.unsafe(nil), &description_override); end
    def clear_generated_description; end
    def configuration; end
    def define_negated_matcher(negated_name, base_name, &description_override); end
    def generated_description; end
    def is_a_describable_matcher?(obj); end
    def is_a_matcher?(obj); end
    def last_description; end
    def last_expectation_handler; end
    def last_expectation_handler=(_arg0); end
    def last_matcher; end
    def last_matcher=(_arg0); end
  end
end

class RSpec::Matchers::AliasedMatcher < ::RSpec::Matchers::MatcherDelegator
  def initialize(base_matcher, description_block); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def method_missing(*_arg0); end
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport < ::RSpec::Matchers::AliasedMatcher; end

class RSpec::Matchers::AliasedNegatedMatcher < ::RSpec::Matchers::AliasedMatcher
  def does_not_match?(*args, &block); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(*args, &block); end

  private

  def optimal_failure_message(same, inverted); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
RSpec::Matchers::BE_PREDICATE_REGEX = T.let(T.unsafe(nil), Regexp)
module RSpec::Matchers::BuiltIn; end

class RSpec::Matchers::BuiltIn::All < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(matcher); end

  def description; end
  def does_not_match?(_actual); end
  def failed_objects; end
  def failure_message; end
  def matcher; end

  private

  def add_new_line_if_needed(message); end
  def failure_message_for_item(index, failure_message); end
  def indent_multiline_message(message); end
  def index_failed_objects; end
  def initialize_copy(other); end
  def iterable?; end
  def match(_expected, _actual); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Pretty
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

  def initialize(expected = T.unsafe(nil)); end

  def actual; end
  def description; end
  def diffable?; end
  def expected; end
  def expects_call_stack_jump?; end
  def match_unless_raises(*exceptions); end
  def matches?(actual); end
  def present_ivars; end
  def rescued_exception; end
  def supports_block_expectations?; end

  private

  def assert_ivars(*expected_ivars); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message; end
  def failure_message_when_negated; end

  class << self
    def has_default_failure_messages?(matcher); end
  end
end

RSpec::Matchers::BuiltIn::BaseMatcher::UNDEFINED = T.let(T.unsafe(nil), Object)

class RSpec::Matchers::BuiltIn::Be < ::RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::BuiltIn::BeHelpers

  def initialize(*args); end

  def <(operand); end
  def <=(operand); end
  def ==(operand); end
  def ===(operand); end
  def =~(operand); end
  def >(operand); end
  def >=(operand); end
  def failure_message; end
  def failure_message_when_negated; end

  private

  def match(_, actual); end
end

class RSpec::Matchers::BuiltIn::BeAKindOf < ::RSpec::Matchers::BuiltIn::BaseMatcher
  private

  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def description; end

  private

  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::BeBetween < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(min, max); end

  def description; end
  def exclusive; end
  def failure_message; end
  def inclusive; end
  def matches?(actual); end

  private

  def comparable?; end
  def compare; end
  def not_comparable_clause; end
end

class RSpec::Matchers::BuiltIn::BeComparedTo < ::RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::BuiltIn::BeHelpers

  def initialize(operand, operator); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(actual); end
end

class RSpec::Matchers::BuiltIn::BeFalsey < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def failure_message; end
  def failure_message_when_negated; end

  private

  def match(_, actual); end
end

module RSpec::Matchers::BuiltIn::BeHelpers
  private

  def args_to_s; end
  def args_to_sentence; end
  def expected_to_sentence; end
  def inspected_args; end
  def parenthesize(string); end
end

class RSpec::Matchers::BuiltIn::BeNil < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def failure_message; end
  def failure_message_when_negated; end

  private

  def match(_, actual); end
end

class RSpec::Matchers::BuiltIn::BePredicate < ::RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::BuiltIn::BeHelpers

  def initialize(*args, &block); end

  def description; end
  def does_not_match?(actual, &block); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(actual, &block); end

  private

  def failure_message_expecting(value); end
  def parse_expected(expected); end
  def predicate; end
  def predicate_accessible?; end
  def predicate_exists?; end
  def predicate_matches?; end
  def prefix_and_expected(symbol); end
  def prefix_to_sentence; end
  def present_tense_predicate; end
  def private_predicate?; end
  def validity_message; end
end

class RSpec::Matchers::BuiltIn::BeTruthy < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def failure_message; end
  def failure_message_when_negated; end

  private

  def match(_, actual); end
end

class RSpec::Matchers::BuiltIn::BeWithin < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(delta); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(actual); end
  def of(expected); end
  def percent_of(expected); end

  private

  def needs_expected; end
  def not_numeric_clause; end
  def numeric?; end
end

module RSpec::Matchers::BuiltIn::CaptureStderr
  class << self
    def capture(block); end
    def name; end
  end
end

module RSpec::Matchers::BuiltIn::CaptureStdout
  class << self
    def capture(block); end
    def name; end
  end
end

class RSpec::Matchers::BuiltIn::Change < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(receiver = T.unsafe(nil), message = T.unsafe(nil), &block); end

  def by(expected_delta); end
  def by_at_least(minimum); end
  def by_at_most(maximum); end
  def description; end
  def does_not_match?(event_proc); end
  def failure_message; end
  def failure_message_when_negated; end
  def from(value); end
  def matches?(event_proc); end
  def supports_block_expectations?; end
  def to(value); end

  private

  def negative_failure_reason; end
  def positive_failure_reason; end
  def raise_block_syntax_error; end
end

class RSpec::Matchers::BuiltIn::ChangeDetails
  def initialize(receiver = T.unsafe(nil), message = T.unsafe(nil), &block); end

  def actual_after; end
  def actual_before; end
  def actual_delta; end
  def changed?; end
  def message; end
  def perform_change(event_proc); end

  private

  def evaluate_value_proc; end
end

class RSpec::Matchers::BuiltIn::ChangeFromValue < ::RSpec::Matchers::BuiltIn::SpecificValuesChange
  def initialize(change_details, expected_before); end

  def does_not_match?(event_proc); end
  def failure_message_when_negated; end
  def to(value); end

  private

  def change_description; end
end

class RSpec::Matchers::BuiltIn::ChangeRelatively < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(change_details, expected_delta, relativity, &comparer); end

  def description; end
  def does_not_match?(_event_proc); end
  def failure_message; end
  def matches?(event_proc); end
  def supports_block_expectations?; end

  private

  def failure_reason; end
end

class RSpec::Matchers::BuiltIn::ChangeToValue < ::RSpec::Matchers::BuiltIn::SpecificValuesChange
  def initialize(change_details, expected_after); end

  def does_not_match?(_event_proc); end
  def from(value); end

  private

  def change_description; end
end

class RSpec::Matchers::BuiltIn::Compound < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(matcher_1, matcher_2); end

  def description; end
  def does_not_match?(_actual); end
  def expects_call_stack_jump?; end
  def matcher_1; end
  def matcher_2; end
  def supports_block_expectations?; end

  private

  def compound_failure_message; end
  def indent_multiline_message(message); end
  def initialize_copy(other); end
  def match(_expected, actual); end
  def matcher_1_matches?; end
  def matcher_2_matches?; end
  def matcher_supports_block_expectations?(matcher); end
  def multiline?(message); end
  def multiline_message(message_1, message_2); end
  def singleline_message(message_1, message_2); end
end

class RSpec::Matchers::BuiltIn::Compound::And < ::RSpec::Matchers::BuiltIn::Compound
  def failure_message; end

  private

  def conjunction; end
  def match(*_arg0); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end

  private

  def inner_matcher_block(outer_args); end
  def order_block_matchers; end

  class << self
    def matcher_expects_call_stack_jump?(matcher); end
  end
end

class RSpec::Matchers::BuiltIn::Compound::Or < ::RSpec::Matchers::BuiltIn::Compound
  def failure_message; end

  private

  def conjunction; end
  def match(*_arg0); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *_arg1); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::ContainExactly < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def description; end
  def failure_message; end
  def failure_message_when_negated; end

  private

  def best_solution; end
  def convert_actual_to_an_array; end
  def extra_items; end
  def match(_expected, _actual); end
  def match_when_sorted?; end
  def missing_items; end
  def pairings_maximizer; end
  def safe_sort(array); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def actual_to_expected_matched_indexes; end
  def expected_to_actual_matched_indexes; end
  def find_best_solution; end
  def solution; end

  private

  def apply_pairing_to(indeterminates, original_matches, other_list_index); end
  def best_solution_for_pairing(expected_index, actual_index); end
  def categorize_indexes(indexes_to_categorize, other_indexes); end
  def reciprocal_single_match?(matches, index, other_list); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  class << self
    def worse_than?(_other); end
  end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution < ::Struct
  def +(derived_candidate_solution); end
  def candidate?; end
  def ideal?; end
  def indeterminate_actual_indexes; end
  def indeterminate_actual_indexes=(_); end
  def indeterminate_expected_indexes; end
  def indeterminate_expected_indexes=(_); end
  def unmatched_actual_indexes; end
  def unmatched_actual_indexes=(_); end
  def unmatched_expected_indexes; end
  def unmatched_expected_indexes=(_); end
  def unmatched_item_count; end
  def worse_than?(other); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RSpec::Matchers::BuiltIn::Cover < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(*expected); end

  def does_not_match?(range); end
  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::EndWith < ::RSpec::Matchers::BuiltIn::StartAndEndWith
  private

  def element_matches?; end
  def subset_matches?; end
end

class RSpec::Matchers::BuiltIn::Eq < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def description; end
  def diffable?; end
  def failure_message; end
  def failure_message_when_negated; end

  private

  def format_date_time(date_time); end
  def format_object(object); end
  def format_time(time); end
  def match(expected, actual); end
end

RSpec::Matchers::BuiltIn::Eq::DATE_TIME_FORMAT = T.let(T.unsafe(nil), String)
RSpec::Matchers::BuiltIn::Eq::TIME_FORMAT = T.let(T.unsafe(nil), String)

class RSpec::Matchers::BuiltIn::Eql < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def diffable?; end
  def failure_message; end
  def failure_message_when_negated; end

  private

  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::Equal < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def diffable?; end
  def failure_message; end
  def failure_message_when_negated; end

  private

  def actual_inspected; end
  def detailed_failure_message; end
  def expected_is_a_literal_singleton?; end
  def inspect_object(o); end
  def match(expected, actual); end
  def simple_failure_message; end
end

RSpec::Matchers::BuiltIn::Equal::LITERAL_SINGLETONS = T.let(T.unsafe(nil), Array)

class RSpec::Matchers::BuiltIn::Exist < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(*expected); end

  def does_not_match?(actual); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(actual); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest < ::Struct
  def actual_exists?; end
  def valid_test?; end
  def validity_message; end

  private

  def existence_values; end
  def predicates; end
  def uniq_truthy_values; end
end

class RSpec::Matchers::BuiltIn::Has < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(method_name, *args, &block); end

  def description; end
  def does_not_match?(actual, &block); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(actual, &block); end

  private

  def args_description; end
  def failure_message_args_description; end
  def method_description; end
  def predicate; end
  def predicate_accessible?; end
  def predicate_exists?; end
  def predicate_matches?; end
  def private_predicate?; end
  def validity_message; end
end

class RSpec::Matchers::BuiltIn::HaveAttributes < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(expected); end

  def description; end
  def does_not_match?(actual); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(actual); end
  def respond_to_failed; end

  private

  def actual_has_attribute?(attribute_key, attribute_value); end
  def perform_match(predicate); end
  def respond_to_attributes?; end
  def respond_to_failure_message_or; end
  def respond_to_matcher; end
end

class RSpec::Matchers::BuiltIn::Include < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(*expected); end

  def description; end
  def diffable?; end
  def does_not_match?(actual); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(actual); end

  private

  def actual_collection_includes?(expected_item); end
  def actual_hash_has_key?(expected_key); end
  def actual_hash_includes?(expected_key, expected_value); end
  def comparing_hash_keys?(expected_item); end
  def comparing_hash_to_a_subset?(expected_item); end
  def invalid_type_message; end
  def perform_match(predicate, hash_subset_predicate); end
end

class RSpec::Matchers::BuiltIn::Match < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def description; end
  def diffable?; end

  private

  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher < ::RSpec::Matchers::BuiltIn::OperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

module RSpec::Matchers::BuiltIn::NullCapture
  class << self
    def capture(_block); end
    def name; end
  end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def initialize(actual); end

  def !=(_expected); end
  def !~(_expected); end
  def <(expected); end
  def <=(expected); end
  def ==(expected); end
  def ===(expected); end
  def =~(expected); end
  def >(expected); end
  def >=(expected); end
  def description; end
  def fail_with_message(message); end

  private

  def eval_match(actual, operator, expected); end
  def has_non_generic_implementation_of?(op); end

  class << self
    def get(klass, operator); end
    def register(klass, operator, matcher); end
    def registry; end
    def unregister(klass, operator); end
    def use_custom_matcher_or_delegate(operator); end
  end
end

class RSpec::Matchers::BuiltIn::Output < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(expected); end

  def description; end
  def diffable?; end
  def does_not_match?(block); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(block); end
  def supports_block_expectations?; end
  def to_stderr; end
  def to_stdout; end

  private

  def actual_output_description; end
  def captured?; end
  def negative_failure_reason; end
  def positive_failure_reason; end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher < ::RSpec::Matchers::BuiltIn::OperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable

  def initialize(expected_error_or_message = T.unsafe(nil), expected_message = T.unsafe(nil), &block); end

  def description; end
  def does_not_match?(given_proc); end
  def expects_call_stack_jump?; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(given_proc, negative_expectation = T.unsafe(nil), &block); end
  def supports_block_expectations?; end
  def with_message(expected_message); end

  private

  def block_matches?; end
  def error_and_message_match?; end
  def eval_block; end
  def expectation_matched?; end
  def expected_error; end
  def expecting_specific_exception?; end
  def format_backtrace(backtrace); end
  def given_error; end
  def prevent_invalid_expectations; end
  def raise_message_already_set; end
  def verify_message; end
end

class RSpec::Matchers::BuiltIn::RespondTo < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(*names); end

  def argument; end
  def arguments; end
  def description; end
  def does_not_match?(actual); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(actual); end
  def with(n); end

  private

  def find_failing_method_names(actual, filter_method); end
  def matches_arity?(actual, name); end
  def pp_names; end
  def with_arity; end
end

class RSpec::Matchers::BuiltIn::Satisfy < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(&block); end

  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::SpecificValuesChange < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(change_details, from, to); end

  def description; end
  def failure_message; end
  def matches?(event_proc); end
  def supports_block_expectations?; end

  private

  def after_value_failure; end
  def before_value_failure; end
  def did_change_failure; end
  def did_not_change_failure; end
  def matches_after?; end
  def matches_before?; end
  def not_given_a_block_failure; end
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

class RSpec::Matchers::BuiltIn::StartAndEndWith < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(*expected); end

  def description; end
  def failure_message; end

  private

  def actual_is_unordered; end
  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::StartWith < ::RSpec::Matchers::BuiltIn::StartAndEndWith
  private

  def element_matches?; end
  def subset_matches?; end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable

  def initialize(expected_symbol = T.unsafe(nil), expected_arg = T.unsafe(nil)); end

  def description; end
  def does_not_match?(given_proc); end
  def expects_call_stack_jump?; end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(given_proc); end
  def supports_block_expectations?; end

  private

  def actual_result; end
  def caught; end
  def expected(symbol_desc = T.unsafe(nil)); end
  def throw_description(symbol, arg); end
end

class RSpec::Matchers::BuiltIn::YieldControl < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize; end

  def at_least(number); end
  def at_most(number); end
  def does_not_match?(block); end
  def exactly(number); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(block); end
  def once; end
  def supports_block_expectations?; end
  def thrice; end
  def times; end
  def twice; end

  private

  def failure_reason; end
  def human_readable_count; end
  def human_readable_expecation_type; end
  def set_expected_yields_count(relativity, n); end
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def initialize(block); end

  def assert_used!; end
  def assert_valid_expect_block!; end
  def has_block?; end
  def num_yields; end
  def num_yields=(_arg0); end
  def single_yield_args; end
  def successive_yield_args; end
  def to_proc; end
  def yielded_args; end
  def yielded_args=(_arg0); end
  def yielded_once?(matcher_name); end

  class << self
    def probe(block); end
  end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(*args); end

  def description; end
  def does_not_match?(block); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(block); end
  def supports_block_expectations?; end

  private

  def args_match?; end
  def expected_arg_description; end
  def negative_failure_reason; end
  def positive_failure_reason; end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def initialize(*args); end

  def description; end
  def does_not_match?(block); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(block); end
  def supports_block_expectations?; end

  private

  def all_args_match?; end
  def args_match?; end
  def expected_arg_description; end
  def negative_failure_reason; end
  def positive_failure_reason; end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs < ::RSpec::Matchers::BuiltIn::BaseMatcher
  def does_not_match?(block); end
  def failure_message; end
  def failure_message_when_negated; end
  def matches?(block); end
  def supports_block_expectations?; end

  private

  def negative_failure_reason; end
  def positive_failure_reason; end
end

module RSpec::Matchers::Composable
  def &(matcher); end
  def ===(value); end
  def and(matcher); end
  def or(matcher); end
  def |(matcher); end

  private

  def description_of(object); end
  def enumerable?(item); end
  def surface_descriptions_in(item); end
  def values_match?(expected, actual); end
  def with_matchers_cloned(object); end

  class << self
    def enumerable?(item); end
    def surface_descriptions_in(item); end
  end
end

class RSpec::Matchers::Composable::DescribableItem < ::Struct
  def inspect; end
  def item; end
  def item=(_); end
  def pretty_print(pp); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module RSpec::Matchers::DSL
  def define(name, &declarations); end
  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

  def description; end
  def diffable?; end
  def expects_call_stack_jump?; end
  def supports_block_expectations?; end

  private

  def chained_method_clause_sentences; end
end

module RSpec::Matchers::DSL::Macros
  def chain(name, &definition); end
  def description(&definition); end
  def diffable; end
  def failure_message(&definition); end
  def failure_message_when_negated(&definition); end
  def match(&match_block); end
  def match_unless_raises(expected_exception = T.unsafe(nil), &match_block); end
  def match_when_negated(&match_block); end
  def supports_block_expectations; end

  private

  def define_user_override(method_name, user_def, &our_def); end
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end
  def failure_message_for_should_not(&definition); end
  def match_for_should(&definition); end
  def match_for_should_not(&definition); end
end

class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers
  include ::RSpec::Matchers::Pretty
  include ::RSpec::Matchers::Composable
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated

  def initialize(name, declarations, matcher_execution_context, *expected); end

  def actual; end
  def expected; end
  def expected_as_array; end
  def inspect; end
  def rescued_exception; end

  private

  def actual_arg_for(block); end
  def method_missing(method, *args, &block); end
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

RSpec::Matchers::HAS_REGEX = T.let(T.unsafe(nil), Regexp)

class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable

  def initialize(base_matcher); end

  def base_matcher; end
  def method_missing(*args, &block); end

  private

  def initialize_copy(other); end
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end
end

module RSpec::Matchers::Pretty
  def name; end
  def name_to_sentence; end
  def to_sentence(words); end
  def to_word(item); end
  def underscore(camel_cased_word); end

  private

  def improve_hash_formatting(inspect_string); end
  def is_matcher_with_description?(object); end
  def split_words(sym); end

  class << self
    def split_words(sym); end
  end
end

RSpec::SharedContext = RSpec::Core::SharedContext
